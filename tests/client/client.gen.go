// Code generated by oto; DO NOT EDIT.

package client

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"strings"
	"time"

	context "context"
	"github.com/pkg/errors"
	http "net/http"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// Debug writes a line of debug log output.
	Debug func(s string)
}

// New makes a new Client.
func New(remoteHost string) *Client {
	c := &Client{
		RemoteHost: remoteHost,
		Debug:      func(s string) {},
		HTTPClient: &http.Client{Timeout: 10 * time.Second},
	}
	return c
}

// CaseService is the API to handle cases
type CaseService struct {
	client *Client
	token  string
}

// NewCaseService makes a new client for accessing CaseService services.
func NewCaseService(client *Client, token string) *CaseService {
	return &CaseService{
		client: client,
		token:  token,
	}
}

// Delete deletes the specified case
func (s *CaseService) Delete(ctx context.Context, r CaseDeleteRequest) (*CaseDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete: marshal CaseDeleteRequest")
	}
	url := s.client.RemoteHost + "CaseService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		CaseDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseDeleteResponse, nil
}

// Get returns the requested case
func (s *CaseService) Get(ctx context.Context, r CaseGetRequest) (*CaseGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get: marshal CaseGetRequest")
	}
	url := s.client.RemoteHost + "CaseService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		CaseGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseGetResponse, nil
}

// List the cases for a specified user
func (s *CaseService) List(ctx context.Context, r CaseListRequest) (*CaseListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List: marshal CaseListRequest")
	}
	url := s.client.RemoteHost + "CaseService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List")
	}
	defer resp.Body.Close()
	var response struct {
		CaseListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseListResponse, nil
}

// New creates a new case
func (s *CaseService) New(ctx context.Context, r CaseNewRequest) (*CaseNewResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New: marshal CaseNewRequest")
	}
	url := s.client.RemoteHost + "CaseService.New"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New")
	}
	defer resp.Body.Close()
	var response struct {
		CaseNewResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.New: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.New: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseNewResponse, nil
}

// Update updates the specified case
func (s *CaseService) Update(ctx context.Context, r CaseUpdateRequest) (*CaseUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update: marshal CaseUpdateRequest")
	}
	url := s.client.RemoteHost + "CaseService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		CaseUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseUpdateResponse, nil
}

// EventService is the API to handle events
type EventService struct {
	client *Client
	token  string
}

// NewEventService makes a new client for accessing EventService services.
func NewEventService(client *Client, token string) *EventService {
	return &EventService{
		client: client,
		token:  token,
	}
}

// Create creates a new event
func (s *EventService) Create(ctx context.Context, r EventCreateRequest) (*EventCreateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create: marshal EventCreateRequest")
	}
	url := s.client.RemoteHost + "EventService.Create"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create")
	}
	defer resp.Body.Close()
	var response struct {
		EventCreateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Create: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Create: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventCreateResponse, nil
}

// Delete deletes an existing event
func (s *EventService) Delete(ctx context.Context, r EventDeleteRequest) (*EventDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete: marshal EventDeleteRequest")
	}
	url := s.client.RemoteHost + "EventService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		EventDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventDeleteResponse, nil
}

// Get the specified event
func (s *EventService) Get(ctx context.Context, r EventGetRequest) (*EventGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get: marshal EventGetRequest")
	}
	url := s.client.RemoteHost + "EventService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		EventGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventGetResponse, nil
}

// List all events
func (s *EventService) List(ctx context.Context, r EventListRequest) (*EventListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List: marshal EventListRequest")
	}
	url := s.client.RemoteHost + "EventService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List")
	}
	defer resp.Body.Close()
	var response struct {
		EventListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventListResponse, nil
}

// Update updates an existing event
func (s *EventService) Update(ctx context.Context, r EventUpdateRequest) (*EventUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update: marshal EventUpdateRequest")
	}
	url := s.client.RemoteHost + "EventService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		EventUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventUpdateResponse, nil
}

// FileService is the API for handling files
type FileService struct {
	client *Client
	token  string
}

// NewFileService makes a new client for accessing FileService services.
func NewFileService(client *Client, token string) *FileService {
	return &FileService{
		client: client,
		token:  token,
	}
}

// Delete deletes the specified file
func (s *FileService) Delete(ctx context.Context, r FileDeleteRequest) (*FileDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete: marshal FileDeleteRequest")
	}
	url := s.client.RemoteHost + "FileService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		FileDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileDeleteResponse, nil
}

// New uploads a file to the backend
func (s *FileService) New(ctx context.Context, r FileNewRequest) (*FileNewResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New: marshal FileNewRequest")
	}
	url := s.client.RemoteHost + "FileService.New"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New")
	}
	defer resp.Body.Close()
	var response struct {
		FileNewResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.New: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.New: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileNewResponse, nil
}

// Open opens a file
func (s *FileService) Open(ctx context.Context, r FileOpenRequest) (*FileOpenResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open: marshal FileOpenRequest")
	}
	url := s.client.RemoteHost + "FileService.Open"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open")
	}
	defer resp.Body.Close()
	var response struct {
		FileOpenResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Open: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Open: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileOpenResponse, nil
}

// Update updates the information for a file
func (s *FileService) Update(ctx context.Context, r FileUpdateRequest) (*FileUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update: marshal FileUpdateRequest")
	}
	url := s.client.RemoteHost + "FileService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		FileUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileUpdateResponse, nil
}

// LinkService is a API for creating links between objects
type LinkService struct {
	client *Client
	token  string
}

// NewLinkService makes a new client for accessing LinkService services.
func NewLinkService(client *Client, token string) *LinkService {
	return &LinkService{
		client: client,
		token:  token,
	}
}

// CreateEvent creates a link for an event with multiple objects
func (s *LinkService) CreateEvent(ctx context.Context, r LinkEventCreateRequest) (*LinkEventCreateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.CreateEvent: marshal LinkEventCreateRequest")
	}
	url := s.client.RemoteHost + "LinkService.CreateEvent"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.CreateEvent: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.CreateEvent")
	}
	defer resp.Body.Close()
	var response struct {
		LinkEventCreateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.CreateEvent: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.CreateEvent: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.CreateEvent: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkEventCreateResponse, nil
}

// DeleteEvent deletes all links to the specified event
func (s *LinkService) DeleteEvent(ctx context.Context, r LinkEventDeleteRequest) (*LinkEventDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.DeleteEvent: marshal LinkEventDeleteRequest")
	}
	url := s.client.RemoteHost + "LinkService.DeleteEvent"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.DeleteEvent: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.DeleteEvent")
	}
	defer resp.Body.Close()
	var response struct {
		LinkEventDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.DeleteEvent: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.DeleteEvent: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.DeleteEvent: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkEventDeleteResponse, nil
}

// GetEvent gets an event with its links
func (s *LinkService) GetEvent(ctx context.Context, r LinkEventGetRequest) (*LinkEventGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.GetEvent: marshal LinkEventGetRequest")
	}
	url := s.client.RemoteHost + "LinkService.GetEvent"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.GetEvent: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.GetEvent")
	}
	defer resp.Body.Close()
	var response struct {
		LinkEventGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.GetEvent: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.GetEvent: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.GetEvent: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkEventGetResponse, nil
}

// UpdateEvent updates links for the specified event
func (s *LinkService) UpdateEvent(ctx context.Context, r LinkEventUpdateRequest) (*LinkEventUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.UpdateEvent: marshal LinkEventUpdateRequest")
	}
	url := s.client.RemoteHost + "LinkService.UpdateEvent"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.UpdateEvent: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.UpdateEvent")
	}
	defer resp.Body.Close()
	var response struct {
		LinkEventUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.UpdateEvent: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.UpdateEvent: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.UpdateEvent: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkEventUpdateResponse, nil
}

// ProcessService is the API - that handles evidence-processing
type ProcessService struct {
	client *Client
	token  string
}

// NewProcessService makes a new client for accessing ProcessService services.
func NewProcessService(client *Client, token string) *ProcessService {
	return &ProcessService{
		client: client,
		token:  token,
	}
}

// Abort aborts the specified processing-job
func (s *ProcessService) Abort(ctx context.Context, r ProcessAbortRequest) (*ProcessAbortResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Abort: marshal ProcessAbortRequest")
	}
	url := s.client.RemoteHost + "ProcessService.Abort"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Abort: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Abort")
	}
	defer resp.Body.Close()
	var response struct {
		ProcessAbortResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ProcessService.Abort: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Abort: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ProcessService.Abort: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ProcessAbortResponse, nil
}

// Jobs returns the status of all processing-jobs in the specified case
func (s *ProcessService) Jobs(ctx context.Context, r ProcessJobsRequest) (*ProcessJobsResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Jobs: marshal ProcessJobsRequest")
	}
	url := s.client.RemoteHost + "ProcessService.Jobs"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Jobs: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Jobs")
	}
	defer resp.Body.Close()
	var response struct {
		ProcessJobsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ProcessService.Jobs: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Jobs: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ProcessService.Jobs: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ProcessJobsResponse, nil
}

// Pause pauses the specified processing-job
func (s *ProcessService) Pause(ctx context.Context, r ProcessPauseRequest) (*ProcessPauseResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Pause: marshal ProcessPauseRequest")
	}
	url := s.client.RemoteHost + "ProcessService.Pause"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Pause: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Pause")
	}
	defer resp.Body.Close()
	var response struct {
		ProcessPauseResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ProcessService.Pause: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Pause: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ProcessService.Pause: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ProcessPauseResponse, nil
}

// Start starts a processing with the specified files
func (s *ProcessService) Start(ctx context.Context, r ProcessStartRequest) (*ProcessStartResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Start: marshal ProcessStartRequest")
	}
	url := s.client.RemoteHost + "ProcessService.Start"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Start: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Start")
	}
	defer resp.Body.Close()
	var response struct {
		ProcessStartResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ProcessService.Start: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ProcessService.Start: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ProcessService.Start: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ProcessStartResponse, nil
}

// TestService is used for testing-purposes
type TestService struct {
	client *Client
	token  string
}

// NewTestService makes a new client for accessing TestService services.
func NewTestService(client *Client, token string) *TestService {
	return &TestService{
		client: client,
		token:  token,
	}
}

// CreateUser creates a test-user in Firebase
func (s *TestService) CreateUser(ctx context.Context, r TestCreateUserRequest) (*TestCreateUserResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser: marshal TestCreateUserRequest")
	}
	url := s.client.RemoteHost + "TestService.CreateUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser")
	}
	defer resp.Body.Close()
	var response struct {
		TestCreateUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "TestService.CreateUser: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("TestService.CreateUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.TestCreateUserResponse, nil
}

// DeleteUser deletes a test-user in Firebase
func (s *TestService) DeleteUser(ctx context.Context, r TestDeleteUserRequest) (*TestDeleteUserResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser: marshal TestDeleteUserRequest")
	}
	url := s.client.RemoteHost + "TestService.DeleteUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser")
	}
	defer resp.Body.Close()
	var response struct {
		TestDeleteUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "TestService.DeleteUser: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("TestService.DeleteUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.TestDeleteUserResponse, nil
}

// Base model for the database
type Base struct {
	// ID is the identifier for the object
	ID string `json:"id"`

	// CreatedAt - when the object was created
	CreatedAt int64 `json:"createdAt"`

	// UpdatedAt - when the object was updated
	UpdatedAt int64 `json:"updatedAt"`

	// DeletedAt - when the object was deleted
	DeletedAt int64 `json:"deletedAt"`
}

// File holds information about an uploaded file
type File struct {
	Base

	// Name of the file
	Name string `json:"name"`

	// Mime is the mime-type of the file
	Mime string `json:"mime"`

	// Description of the file
	Description string `json:"description"`

	// Path to where the file is stored
	Path string `json:"path"`

	// Size of the file in bytes
	Size int `json:"size"`

	// Processed is if the file has been processed or not
	Processed bool `json:"processed"`
}

// Process holds information about a job that processes data to app
type Process struct {
	Base
}

// Case is an object to hold data for a specific investigation
type Case struct {
	Base

	// CreatorID is the user-id of the user who created the case (super admin)
	CreatorID string `json:"creatorID"`

	// Name of the case
	Name string `json:"name"`

	// Description of the case
	Description string `json:"description"`

	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`

	// Investigators of the case (users who has access to the case)
	Investigators []string `json:"investigators"`

	// Files that exists in the case
	Files []File `json:"files"`

	// Processes that exists in the case
	Processes []Process `json:"processes"`
}

// CaseDeleteRequest is the input-object for deleting an existing case
type CaseDeleteRequest struct {
	// ID of the case to delete
	ID string `json:"id"`
}

// CaseDeleteResponse is the output-object for deleting an existing case
type CaseDeleteResponse struct {
}

// CaseGetRequest is the input-object for getting a specified case
type CaseGetRequest struct {
	// ID of the case to get
	ID string `json:"id"`
}

// CaseGetResponse is the output-object for getting a specified case
type CaseGetResponse struct {
	Case Case `json:"case"`
}

// CaseListRequest is the input-object for listing cases for a specified user
type CaseListRequest struct {
	// UserID of the user to list cases for
	UserID string `json:"userID"`
}

// CaseListResponse is the output-object for listing cases for a specified user
type CaseListResponse struct {
	Cases []Case `json:"cases"`
}

// CaseNewRequest is the input-object for creating a new case
type CaseNewRequest struct {
	// Name of the case
	Name string `json:"name"`

	// description of the case to create
	Description string `json:"description"`

	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
}

// CaseNewResponse is the output-object for creating a new case
type CaseNewResponse struct {
	New Case `json:"new"`
}

// CaseUpdateRequest is the input-object for updating an existing case
type CaseUpdateRequest struct {
	// ID of the case to update
	ID string `json:"id"`

	// Name of the case
	Name string `json:"name"`

	// description of the case to create
	Description string `json:"description"`

	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
}

// CaseUpdateResponse is the output-object for updating an existing case
type CaseUpdateResponse struct {
	Updated Case `json:"updated"`
}

// CaseUploadRequest is the input-object for uploading an evidence to the case
type CaseUploadRequest struct {
	// ID of the case to upload
	ID string `json:"id"`

	// Name of the item to upload
	Name string `json:"name"`
}

// Event is an important happening that needs investigation.
type Event struct {
	Base

	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`

	// Desription of the event.
	Description string `json:"description"`

	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventCreateRequest is the input-object for creating an event
type EventCreateRequest struct {
	// CaseID of the case to create the event for
	CaseID string `json:"caseID"`

	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`

	// Desription of the event.
	Description string `json:"description"`

	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventCreateResponse is the output-object for creating an event
type EventCreateResponse struct {
	Created Event `json:"created"`
}

// EventDeleteRequest is the input-object for deleting an existing event
type EventDeleteRequest struct {
	// ID of the event to Delete
	ID string `json:"id"`

	// CaseID of the event
	CaseID string `json:"caseID"`
}

// EventDeleteResponse is the output-object for deleting an existing event
type EventDeleteResponse struct {
}

// EventGetRequest is the input-object for getting an existing event
type EventGetRequest struct {
	// ID of the event to get
	ID string `json:"id"`

	// CaseID of the event
	CaseID string `json:"caseID"`
}

// EventGetResponse is the output-object for deleting an existing event
type EventGetResponse struct {
	Event Event `json:"event"`
}

// EventListRequest is the input-object for listing all existing events for a case
type EventListRequest struct {
	// CaseID to list the events for
	CaseID string `json:"caseID"`
}

// EventListResponse is the output-object for listing all existing events for a
// case
type EventListResponse struct {
	Events []Event `json:"events"`
}

// EventUpdateRequest is the input-object for updating an existing event
type EventUpdateRequest struct {
	// ID of the event to update
	ID string `json:"id"`

	// CaseID of the event
	CaseID string `json:"caseID"`

	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`

	// Desription of the event.
	Description string `json:"description"`

	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventUpdateResponse is the output-object for updating an existing event
type EventUpdateResponse struct {
	Updated Event `json:"updated"`
}

// FileDeleteRequest is the input-object for deleting a file
type FileDeleteRequest struct {
	// ID of the file to delete
	ID string `json:"id"`

	// CaseID of the case where the file to delete belongs
	CaseID string `json:"caseID"`
}

// FileDeleteResponse is the output-object for deleting a file
type FileDeleteResponse struct {
}

// FileNewRequest is the input-object for creating a new file
type FileNewRequest struct {
	// CaseID of the case to upload the file
	CaseID string `json:"caseID"`

	// Name of the file
	Name string `json:"name"`

	// Description of the file
	Description string `json:"description"`

	// Mime is the mime-type of the file (decided by frontend)
	Mime string `json:"mime"`

	// Data of the file (base64 encoded)
	Data string `json:"data"`
}

// FileNewResponse is the output-object for creating a new file
type FileNewResponse struct {
	New File `json:"new"`
}

// FileOpenRequest is the input-object for opening a file in a case
type FileOpenRequest struct {
	// ID of the file to open
	ID string `json:"id"`

	// CaseID of the case to open the file
	CaseID string `json:"caseID"`
}

// FileOpenResponse is the output-object for opening a file in a case
type FileOpenResponse struct {
	// Data contains the b64-encoded data for the file
	Data string `json:"data"`
}

// FileUpdateRequest is the input-object for updating a files information
type FileUpdateRequest struct {
	// ID of the file to update
	ID string `json:"id"`

	// CaseID of the case where the file to update belongs
	CaseID string `json:"caseID"`

	// Description of the file
	Description string `json:"description"`
}

// FileUpdateResponse is the output-object for updating a files information
type FileUpdateResponse struct {
	Updated File `json:"updated"`
}

// LinkEvent is a link for an event between different objects
type LinkEvent struct {
	Base

	// From which event has been linked
	From Event `json:"from"`

	// Events that has been linked
	Events []Event `json:"events"`
}

// LinkEventCreateRequest is the input-object for linking objects with an event
type LinkEventCreateRequest struct {
	// CaseID for the event
	CaseID string `json:"caseID"`

	// FromID is the ID of the event to hold the link
	FromID string `json:"fromID"`

	// EventIDs of the events to be linked
	EventIDs []string `json:"eventIDs"`

	// Bidirectional means that he link also should be created for the "ToID"
	Bidirectional bool `json:"bidirectional"`
}

// LinkEventCreateResponse is the output-object for linking objects with an event
type LinkEventCreateResponse struct {
	Linked LinkEvent `json:"linked"`
}

// LinkEventDeleteRequest is the input-object for removing a linked event
type LinkEventDeleteRequest struct {
	// CaseID of the case where the linked event belongs
	CaseID string `json:"caseID"`

	// EventID of the Event to delete the link for
	EventID string `json:"eventID"`
}

// LinkEventDeleteResponse is the output-object for removing a linked event
type LinkEventDeleteResponse struct {
}

// LinkEventGetRequest is the input-object for getting a linked Event
type LinkEventGetRequest struct {
	// CaseID of the case where the event belongs
	CaseID string `json:"caseID"`

	// EventID of the Event to get all links for
	EventID string `json:"eventID"`
}

// LinkEventGetResponse is the output-object for getting a linked Event
type LinkEventGetResponse struct {
	Link LinkEvent `json:"link"`
}

// LinkEventUpdateRequest is the input-object for updating linked objects with an
// event
type LinkEventUpdateRequest struct {
	// EventID is the ID of the event to hold the link
	EventID string `json:"eventID"`

	// CaseID for the event
	CaseID string `json:"caseID"`

	// EventAddIDs of the events to be linked
	EventAddIDs []string `json:"eventAddIDs"`

	// EventRemoveIDs of the events to be removed
	EventRemoveIDs []string `json:"eventRemoveIDs"`
}

// LinkEventUpdateResponse is the output-object for linking objects with an event
type LinkEventUpdateResponse struct {
	Updated LinkEvent `json:"updated"`
}

// ProcessAbortRequest is the input-object for aborting a processing-job
type ProcessAbortRequest struct {
	// ID of the processing-job to abort
	ID string `json:"id"`

	// CaseID of the case the processing-job belongs to
	CaseID string `json:"caseID"`
}

// ProcessAbortResponse is the output-object for aborting a processing-job
type ProcessAbortResponse struct {
	Aborted Process `json:"aborted"`
}

// ProcessJobsRequest is the input-object for getting all processing-jobs for a
// case
type ProcessJobsRequest struct {
	// CaseID of the case to get the processing-jobs for
	CaseID string `json:"caseID"`
}

// ProcessJobsResponse is the output-object for getting all processing-jobs for a
// case
type ProcessJobsResponse struct {
	Processes []Process `json:"processes"`
}

// ProcessPauseRequest is the input-object for pausing a processing-job
type ProcessPauseRequest struct {
	// ID of the processing-job to pause
	ID string `json:"id"`

	// CaseID of the case the processing-job belongs to
	CaseID string `json:"caseID"`
}

// ProcessPauseResponse is the output-object for pausing a processing-job
type ProcessPauseResponse struct {
	Paused Process `json:"paused"`
}

// ProcessStartRequest is the input-object for starting a processing-job
type ProcessStartRequest struct {
	// CaseID of the case to start the processing for
	CaseID string `json:"caseID"`

	// FileIDs of the files to process
	FileIDs []string `json:"fileIDs"`
}

// ProcessStartResponse is the output-object for starting a processing-job
type ProcessStartResponse struct {
	Started Process `json:"started"`
}

// TestCreateUserRequest is the input-object for creating a test-user
type TestCreateUserRequest struct {
	// Name of the user to create
	Name string `json:"name"`

	// ID of the user to create
	ID string `json:"id"`

	// Email of the user to create
	Email string `json:"email"`

	// Password for the new user
	Password string `json:"password"`

	// Secret for using the test-service
	Secret string `json:"secret,omitempty"`
}

// TestCreateUserResponse is the output-object for creating a test-user
type TestCreateUserResponse struct {
	// Token for the created user
	Token string `json:"token"`
}

// TestDeleteUserRequest is the input-object for deleting a test-user
type TestDeleteUserRequest struct {
	// ID of the user to delete
	ID string `json:"id"`

	// Secret for using the test-service
	Secret string `json:"secret,omitempty"`
}

// TestDeleteUserResponse is the output-object for deleting a test-user
type TestDeleteUserResponse struct {
}

// User holds information for a user in the timeline-investigator
type User struct {
	DisplayName string `json:"displayName"`

	Email string `json:"email"`

	PhoneNumber string `json:"phoneNumber"`

	PhotoURL string `json:"photoURL"`

	ProviderID string `json:"providerID"`

	UID string `json:"uID"`
}
