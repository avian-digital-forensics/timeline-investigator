// Code generated by oto; DO NOT EDIT.

package client

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"strings"
	"time"

	context "context"
	"github.com/pkg/errors"
	http "net/http"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// Debug writes a line of debug log output.
	Debug func(s string)
}

// New makes a new Client.
func New(remoteHost string) *Client {
	c := &Client{
		RemoteHost: remoteHost,
		Debug:      func(s string) {},
		HTTPClient: &http.Client{Timeout: 10 * time.Second},
	}
	return c
}

// CaseService is the API to handle cases
type CaseService struct {
	client *Client
	token  string
}

// NewCaseService makes a new client for accessing CaseService services.
func NewCaseService(client *Client, token string) *CaseService {
	return &CaseService{
		client: client,
		token:  token,
	}
}

// Delete deletes the specified case
func (s *CaseService) Delete(ctx context.Context, r CaseDeleteRequest) (*CaseDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete: marshal CaseDeleteRequest")
	}
	url := s.client.RemoteHost + "CaseService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		CaseDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseDeleteResponse, nil
}

// Get returns the requested case
func (s *CaseService) Get(ctx context.Context, r CaseGetRequest) (*CaseGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get: marshal CaseGetRequest")
	}
	url := s.client.RemoteHost + "CaseService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		CaseGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseGetResponse, nil
}

// Keywords lists all the keywords for the case
func (s *CaseService) Keywords(ctx context.Context, r CaseKeywordsRequest) (*CaseKeywordsResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Keywords: marshal CaseKeywordsRequest")
	}
	url := s.client.RemoteHost + "CaseService.Keywords"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Keywords: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Keywords")
	}
	defer resp.Body.Close()
	var response struct {
		CaseKeywordsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Keywords: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Keywords: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Keywords: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseKeywordsResponse, nil
}

// List the cases for a specified user
func (s *CaseService) List(ctx context.Context, r CaseListRequest) (*CaseListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List: marshal CaseListRequest")
	}
	url := s.client.RemoteHost + "CaseService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List")
	}
	defer resp.Body.Close()
	var response struct {
		CaseListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.List: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseListResponse, nil
}

// New creates a new case
func (s *CaseService) New(ctx context.Context, r CaseNewRequest) (*CaseNewResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New: marshal CaseNewRequest")
	}
	url := s.client.RemoteHost + "CaseService.New"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New")
	}
	defer resp.Body.Close()
	var response struct {
		CaseNewResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.New: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.New: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.New: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseNewResponse, nil
}

// Update updates the specified case
func (s *CaseService) Update(ctx context.Context, r CaseUpdateRequest) (*CaseUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update: marshal CaseUpdateRequest")
	}
	url := s.client.RemoteHost + "CaseService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		CaseUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CaseService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CaseService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CaseService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CaseUpdateResponse, nil
}

// EntityService is the API to handle entities
type EntityService struct {
	client *Client
	token  string
}

// NewEntityService makes a new client for accessing EntityService services.
func NewEntityService(client *Client, token string) *EntityService {
	return &EntityService{
		client: client,
		token:  token,
	}
}

// Create creates a new entity
func (s *EntityService) Create(ctx context.Context, r EntityCreateRequest) (*EntityCreateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Create: marshal EntityCreateRequest")
	}
	url := s.client.RemoteHost + "EntityService.Create"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Create: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Create")
	}
	defer resp.Body.Close()
	var response struct {
		EntityCreateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.Create: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Create: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.Create: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EntityCreateResponse, nil
}

// Delete deletes an existing entity
func (s *EntityService) Delete(ctx context.Context, r EntityDeleteRequest) (*EntityDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Delete: marshal EntityDeleteRequest")
	}
	url := s.client.RemoteHost + "EntityService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		EntityDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EntityDeleteResponse, nil
}

// Get the specified entity
func (s *EntityService) Get(ctx context.Context, r EntityGetRequest) (*EntityGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Get: marshal EntityGetRequest")
	}
	url := s.client.RemoteHost + "EntityService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		EntityGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EntityGetResponse, nil
}

// KeywordsAdd to an entity
func (s *EntityService) KeywordsAdd(ctx context.Context, r KeywordsAddRequest) (*KeywordsAddResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsAdd: marshal KeywordsAddRequest")
	}
	url := s.client.RemoteHost + "EntityService.KeywordsAdd"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsAdd: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsAdd")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsAddResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.KeywordsAdd: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsAdd: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.KeywordsAdd: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsAddResponse, nil
}

// KeywordsRemove from an entity
func (s *EntityService) KeywordsRemove(ctx context.Context, r KeywordsRemoveRequest) (*KeywordsRemoveResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsRemove: marshal KeywordsRemoveRequest")
	}
	url := s.client.RemoteHost + "EntityService.KeywordsRemove"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsRemove: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsRemove")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsRemoveResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.KeywordsRemove: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.KeywordsRemove: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.KeywordsRemove: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsRemoveResponse, nil
}

// List all entities
func (s *EntityService) List(ctx context.Context, r EntityListRequest) (*EntityListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.List: marshal EntityListRequest")
	}
	url := s.client.RemoteHost + "EntityService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.List: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.List")
	}
	defer resp.Body.Close()
	var response struct {
		EntityListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.List: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EntityListResponse, nil
}

// Types returns the existing entity-types
func (s *EntityService) Types(ctx context.Context, r EntityTypesRequest) (*EntityTypesResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Types: marshal EntityTypesRequest")
	}
	url := s.client.RemoteHost + "EntityService.Types"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Types: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Types")
	}
	defer resp.Body.Close()
	var response struct {
		EntityTypesResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.Types: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Types: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.Types: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EntityTypesResponse, nil
}

// Update updates an existing entity
func (s *EntityService) Update(ctx context.Context, r EntityUpdateRequest) (*EntityUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Update: marshal EntityUpdateRequest")
	}
	url := s.client.RemoteHost + "EntityService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		EntityUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EntityService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EntityService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EntityService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EntityUpdateResponse, nil
}

// EventService is the API to handle events
type EventService struct {
	client *Client
	token  string
}

// NewEventService makes a new client for accessing EventService services.
func NewEventService(client *Client, token string) *EventService {
	return &EventService{
		client: client,
		token:  token,
	}
}

// Create creates a new event
func (s *EventService) Create(ctx context.Context, r EventCreateRequest) (*EventCreateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create: marshal EventCreateRequest")
	}
	url := s.client.RemoteHost + "EventService.Create"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create")
	}
	defer resp.Body.Close()
	var response struct {
		EventCreateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Create: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Create: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Create: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventCreateResponse, nil
}

// Delete deletes an existing event
func (s *EventService) Delete(ctx context.Context, r EventDeleteRequest) (*EventDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete: marshal EventDeleteRequest")
	}
	url := s.client.RemoteHost + "EventService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		EventDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventDeleteResponse, nil
}

// Get the specified event
func (s *EventService) Get(ctx context.Context, r EventGetRequest) (*EventGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get: marshal EventGetRequest")
	}
	url := s.client.RemoteHost + "EventService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		EventGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventGetResponse, nil
}

// KeywordsAdd to an event
func (s *EventService) KeywordsAdd(ctx context.Context, r KeywordsAddRequest) (*KeywordsAddResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsAdd: marshal KeywordsAddRequest")
	}
	url := s.client.RemoteHost + "EventService.KeywordsAdd"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsAdd: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsAdd")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsAddResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.KeywordsAdd: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsAdd: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.KeywordsAdd: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsAddResponse, nil
}

// KeywordsRemove from an event
func (s *EventService) KeywordsRemove(ctx context.Context, r KeywordsRemoveRequest) (*KeywordsRemoveResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsRemove: marshal KeywordsRemoveRequest")
	}
	url := s.client.RemoteHost + "EventService.KeywordsRemove"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsRemove: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsRemove")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsRemoveResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.KeywordsRemove: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.KeywordsRemove: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.KeywordsRemove: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsRemoveResponse, nil
}

// List all events
func (s *EventService) List(ctx context.Context, r EventListRequest) (*EventListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List: marshal EventListRequest")
	}
	url := s.client.RemoteHost + "EventService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List")
	}
	defer resp.Body.Close()
	var response struct {
		EventListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.List: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventListResponse, nil
}

// Update updates an existing event
func (s *EventService) Update(ctx context.Context, r EventUpdateRequest) (*EventUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update: marshal EventUpdateRequest")
	}
	url := s.client.RemoteHost + "EventService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		EventUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "EventService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "EventService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("EventService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.EventUpdateResponse, nil
}

// FileService is the API for handling files
type FileService struct {
	client *Client
	token  string
}

// NewFileService makes a new client for accessing FileService services.
func NewFileService(client *Client, token string) *FileService {
	return &FileService{
		client: client,
		token:  token,
	}
}

// Delete deletes the specified file
func (s *FileService) Delete(ctx context.Context, r FileDeleteRequest) (*FileDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete: marshal FileDeleteRequest")
	}
	url := s.client.RemoteHost + "FileService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		FileDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileDeleteResponse, nil
}

// KeywordsAdd to a file
func (s *FileService) KeywordsAdd(ctx context.Context, r KeywordsAddRequest) (*KeywordsAddResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsAdd: marshal KeywordsAddRequest")
	}
	url := s.client.RemoteHost + "FileService.KeywordsAdd"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsAdd: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsAdd")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsAddResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.KeywordsAdd: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsAdd: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.KeywordsAdd: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsAddResponse, nil
}

// KeywordsRemove from a file
func (s *FileService) KeywordsRemove(ctx context.Context, r KeywordsRemoveRequest) (*KeywordsRemoveResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsRemove: marshal KeywordsRemoveRequest")
	}
	url := s.client.RemoteHost + "FileService.KeywordsRemove"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsRemove: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsRemove")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsRemoveResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.KeywordsRemove: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.KeywordsRemove: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.KeywordsRemove: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsRemoveResponse, nil
}

// New uploads a file to the backend
func (s *FileService) New(ctx context.Context, r FileNewRequest) (*FileNewResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New: marshal FileNewRequest")
	}
	url := s.client.RemoteHost + "FileService.New"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New")
	}
	defer resp.Body.Close()
	var response struct {
		FileNewResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.New: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.New: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.New: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileNewResponse, nil
}

// Open opens a file
func (s *FileService) Open(ctx context.Context, r FileOpenRequest) (*FileOpenResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open: marshal FileOpenRequest")
	}
	url := s.client.RemoteHost + "FileService.Open"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open")
	}
	defer resp.Body.Close()
	var response struct {
		FileOpenResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Open: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Open: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Open: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileOpenResponse, nil
}

// Process processes a file
func (s *FileService) Process(ctx context.Context, r FileProcessRequest) (*FileProcessResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Process: marshal FileProcessRequest")
	}
	url := s.client.RemoteHost + "FileService.Process"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Process: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Process")
	}
	defer resp.Body.Close()
	var response struct {
		FileProcessResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Process: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Process: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Process: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileProcessResponse, nil
}

// Processed gets information for a processed file
func (s *FileService) Processed(ctx context.Context, r FileProcessedRequest) (*FileProcessedResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processed: marshal FileProcessedRequest")
	}
	url := s.client.RemoteHost + "FileService.Processed"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processed: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processed")
	}
	defer resp.Body.Close()
	var response struct {
		FileProcessedResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Processed: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processed: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Processed: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileProcessedResponse, nil
}

// Processes gets information for all proccesed files in the specified case
func (s *FileService) Processes(ctx context.Context, r FileProcessesRequest) (*FileProcessesResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processes: marshal FileProcessesRequest")
	}
	url := s.client.RemoteHost + "FileService.Processes"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processes: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processes")
	}
	defer resp.Body.Close()
	var response struct {
		FileProcessesResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Processes: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Processes: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Processes: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileProcessesResponse, nil
}

// Update updates the information for a file
func (s *FileService) Update(ctx context.Context, r FileUpdateRequest) (*FileUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update: marshal FileUpdateRequest")
	}
	url := s.client.RemoteHost + "FileService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		FileUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "FileService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "FileService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("FileService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.FileUpdateResponse, nil
}

// LinkService is a API for creating links between objects
type LinkService struct {
	client *Client
	token  string
}

// NewLinkService makes a new client for accessing LinkService services.
func NewLinkService(client *Client, token string) *LinkService {
	return &LinkService{
		client: client,
		token:  token,
	}
}

// Add adds specified links to an object
func (s *LinkService) Add(ctx context.Context, r LinkAddRequest) (*LinkAddResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Add: marshal LinkAddRequest")
	}
	url := s.client.RemoteHost + "LinkService.Add"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Add: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Add")
	}
	defer resp.Body.Close()
	var response struct {
		LinkAddResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.Add: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Add: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.Add: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkAddResponse, nil
}

// Create creates a links for an object
func (s *LinkService) Create(ctx context.Context, r LinkCreateRequest) (*LinkCreateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Create: marshal LinkCreateRequest")
	}
	url := s.client.RemoteHost + "LinkService.Create"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Create: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Create")
	}
	defer resp.Body.Close()
	var response struct {
		LinkCreateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.Create: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Create: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.Create: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkCreateResponse, nil
}

// Delete deletes all links to the specified object
func (s *LinkService) Delete(ctx context.Context, r LinkDeleteRequest) (*LinkDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Delete: marshal LinkDeleteRequest")
	}
	url := s.client.RemoteHost + "LinkService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		LinkDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkDeleteResponse, nil
}

// Get gets an object with its links
func (s *LinkService) Get(ctx context.Context, r LinkGetRequest) (*LinkGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Get: marshal LinkGetRequest")
	}
	url := s.client.RemoteHost + "LinkService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		LinkGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkGetResponse, nil
}

// Remove removes specified links from an object
func (s *LinkService) Remove(ctx context.Context, r LinkRemoveRequest) (*LinkRemoveResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Remove: marshal LinkRemoveRequest")
	}
	url := s.client.RemoteHost + "LinkService.Remove"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Remove: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Remove")
	}
	defer resp.Body.Close()
	var response struct {
		LinkRemoveResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "LinkService.Remove: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "LinkService.Remove: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("LinkService.Remove: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LinkRemoveResponse, nil
}

// PersonService is the API to handle entities
type PersonService struct {
	client *Client
	token  string
}

// NewPersonService makes a new client for accessing PersonService services.
func NewPersonService(client *Client, token string) *PersonService {
	return &PersonService{
		client: client,
		token:  token,
	}
}

// Create creates a new person
func (s *PersonService) Create(ctx context.Context, r PersonCreateRequest) (*PersonCreateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Create: marshal PersonCreateRequest")
	}
	url := s.client.RemoteHost + "PersonService.Create"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Create: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Create")
	}
	defer resp.Body.Close()
	var response struct {
		PersonCreateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.Create: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Create: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.Create: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.PersonCreateResponse, nil
}

// Delete deletes an existing person
func (s *PersonService) Delete(ctx context.Context, r PersonDeleteRequest) (*PersonDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Delete: marshal PersonDeleteRequest")
	}
	url := s.client.RemoteHost + "PersonService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Delete: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		PersonDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Delete: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.PersonDeleteResponse, nil
}

// Get the specified person
func (s *PersonService) Get(ctx context.Context, r PersonGetRequest) (*PersonGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Get: marshal PersonGetRequest")
	}
	url := s.client.RemoteHost + "PersonService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Get: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		PersonGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Get: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.PersonGetResponse, nil
}

// KeywordsAdd to a person
func (s *PersonService) KeywordsAdd(ctx context.Context, r KeywordsAddRequest) (*KeywordsAddResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsAdd: marshal KeywordsAddRequest")
	}
	url := s.client.RemoteHost + "PersonService.KeywordsAdd"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsAdd: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsAdd")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsAddResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.KeywordsAdd: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsAdd: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.KeywordsAdd: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsAddResponse, nil
}

// KeywordsRemove from a person
func (s *PersonService) KeywordsRemove(ctx context.Context, r KeywordsRemoveRequest) (*KeywordsRemoveResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsRemove: marshal KeywordsRemoveRequest")
	}
	url := s.client.RemoteHost + "PersonService.KeywordsRemove"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsRemove: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsRemove")
	}
	defer resp.Body.Close()
	var response struct {
		KeywordsRemoveResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.KeywordsRemove: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.KeywordsRemove: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.KeywordsRemove: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.KeywordsRemoveResponse, nil
}

// List all entities for a case
func (s *PersonService) List(ctx context.Context, r PersonListRequest) (*PersonListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.List: marshal PersonListRequest")
	}
	url := s.client.RemoteHost + "PersonService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.List: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.List")
	}
	defer resp.Body.Close()
	var response struct {
		PersonListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.List: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.PersonListResponse, nil
}

// Update updates an existing person
func (s *PersonService) Update(ctx context.Context, r PersonUpdateRequest) (*PersonUpdateResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Update: marshal PersonUpdateRequest")
	}
	url := s.client.RemoteHost + "PersonService.Update"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Update: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Update")
	}
	defer resp.Body.Close()
	var response struct {
		PersonUpdateResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "PersonService.Update: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "PersonService.Update: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("PersonService.Update: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.PersonUpdateResponse, nil
}

// SearchService is the API to handle searches in the Timeline-Investigator
type SearchService struct {
	client *Client
	token  string
}

// NewSearchService makes a new client for accessing SearchService services.
func NewSearchService(client *Client, token string) *SearchService {
	return &SearchService{
		client: client,
		token:  token,
	}
}

// SearchWithText returns data in the case that is related to the text
func (s *SearchService) SearchWithText(ctx context.Context, r SearchTextRequest) (*SearchTextResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithText: marshal SearchTextRequest")
	}
	url := s.client.RemoteHost + "SearchService.SearchWithText"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithText: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithText")
	}
	defer resp.Body.Close()
	var response struct {
		SearchTextResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "SearchService.SearchWithText: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithText: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("SearchService.SearchWithText: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.SearchTextResponse, nil
}

// SearchWithTimespan returns events from the selected timespan
func (s *SearchService) SearchWithTimespan(ctx context.Context, r SearchTimespanRequest) (*SearchTimespanResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithTimespan: marshal SearchTimespanRequest")
	}
	url := s.client.RemoteHost + "SearchService.SearchWithTimespan"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithTimespan: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithTimespan")
	}
	defer resp.Body.Close()
	var response struct {
		SearchTimespanResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "SearchService.SearchWithTimespan: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "SearchService.SearchWithTimespan: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("SearchService.SearchWithTimespan: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.SearchTimespanResponse, nil
}

// TestService is used for testing-purposes
type TestService struct {
	client *Client
	token  string
}

// NewTestService makes a new client for accessing TestService services.
func NewTestService(client *Client, token string) *TestService {
	return &TestService{
		client: client,
		token:  token,
	}
}

// CreateUser creates a test-user in Firebase
func (s *TestService) CreateUser(ctx context.Context, r TestCreateUserRequest) (*TestCreateUserResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser: marshal TestCreateUserRequest")
	}
	url := s.client.RemoteHost + "TestService.CreateUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser")
	}
	defer resp.Body.Close()
	var response struct {
		TestCreateUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "TestService.CreateUser: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.CreateUser: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("TestService.CreateUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.TestCreateUserResponse, nil
}

// DeleteUser deletes a test-user in Firebase
func (s *TestService) DeleteUser(ctx context.Context, r TestDeleteUserRequest) (*TestDeleteUserResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser: marshal TestDeleteUserRequest")
	}
	url := s.client.RemoteHost + "TestService.DeleteUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req.Header.Set("Authorization", s.token)
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser")
	}
	defer resp.Body.Close()
	var response struct {
		TestDeleteUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "TestService.DeleteUser: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "TestService.DeleteUser: read response body")
	}
	s.client.Debug(fmt.Sprintf("<< %s", string(respBodyBytes)))
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("TestService.DeleteUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.TestDeleteUserResponse, nil
}

// Base model for the database
type Base struct {
	// ID is the identifier for the object
	ID string `json:"id"`

	// CreatedAt - when the object was created
	CreatedAt int64 `json:"createdAt"`

	// UpdatedAt - when the object was updated
	UpdatedAt int64 `json:"updatedAt"`

	// DeletedAt - when the object was deleted
	DeletedAt int64 `json:"deletedAt"`
}

// File holds information about an uploaded file
type File struct {
	Base

	// Name of the file
	Name string `json:"name"`

	// Mime is the mime-type of the file
	Mime string `json:"mime"`

	// Description of the file
	Description string `json:"description"`

	// Path to where the file is stored
	Path string `json:"path"`

	// Size of the file in bytes
	Size int `json:"size"`

	// ProcessedAt is the unix-timestamp for when (if) the item was processed
	ProcessedAt int64 `json:"processedAt"`

	// The keywords for the file
	Keywords []string `json:"keywords"`
}

// Process holds information about a job that processes data to app
type Process struct {
	Base

	// Files for the process
	Files []string `json:"files"`
}

// Case is an object to hold data for a specific investigation
type Case struct {
	Base

	// CreatorID is the user-id of the user who created the case (super admin)
	CreatorID string `json:"creatorID"`

	// Name of the case
	Name string `json:"name"`

	// Description of the case
	Description string `json:"description"`

	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`

	// Investigators of the case (users who has access to the case)
	Investigators []string `json:"investigators"`

	// Files that exists in the case
	Files []File `json:"files"`

	// Processes that exists in the case
	Processes []Process `json:"processes"`
}

// CaseDeleteRequest is the input-object for deleting an existing case
type CaseDeleteRequest struct {
	// ID of the case to delete
	ID string `json:"id"`
}

// CaseDeleteResponse is the output-object for deleting an existing case
type CaseDeleteResponse struct {
}

// CaseGetRequest is the input-object for getting a specified case
type CaseGetRequest struct {
	// ID of the case to get
	ID string `json:"id"`
}

// CaseGetResponse is the output-object for getting a specified case
type CaseGetResponse struct {
	Case Case `json:"case"`
}

// CaseKeywordsRequest is the input-object for listing keywords for a case
type CaseKeywordsRequest struct {
	// ID for the case to get the keywords for
	ID string `json:"id"`
}

// CaseKeywordsResponse is the output-object for listing keywords for a case
type CaseKeywordsResponse struct {
	// Existing keywords in the case
	Keywords []string `json:"keywords"`
}

// CaseListRequest is the input-object for listing cases for a specified user
type CaseListRequest struct {
	// UserID of the user to list cases for
	UserID string `json:"userID"`
}

// CaseListResponse is the output-object for listing cases for a specified user
type CaseListResponse struct {
	Cases []Case `json:"cases"`
}

// CaseNewRequest is the input-object for creating a new case
type CaseNewRequest struct {
	// Name of the case
	Name string `json:"name"`

	// description of the case to create
	Description string `json:"description"`

	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
}

// CaseNewResponse is the output-object for creating a new case
type CaseNewResponse struct {
	New Case `json:"new"`
}

// CaseUpdateRequest is the input-object for updating an existing case
type CaseUpdateRequest struct {
	// ID of the case to update
	ID string `json:"id"`

	// Name of the case
	Name string `json:"name"`

	// description of the case to create
	Description string `json:"description"`

	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
}

// CaseUpdateResponse is the output-object for updating an existing case
type CaseUpdateResponse struct {
	Updated Case `json:"updated"`
}

// Entity is an object that can be of different types. For example, organization or
// location
type Entity struct {
	Base

	// Title of the entity
	Title string `json:"title"`

	// PhotoURL of the entity. but in the future have it be uploaded and served by the
	// file-service with some security
	PhotoURL string `json:"photoURL"`

	// Type of the entity
	Type string `json:"type"`

	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`

	// The keywords for the entity
	Keywords []string `json:"keywords"`
}

// EntityCreateRequest is the input-object for creating an entity
type EntityCreateRequest struct {
	// CaseID of the case to create the new entity to
	CaseID string `json:"caseID"`

	// Title of the entity
	Title string `json:"title"`

	// PhotoURL of the entity. but in the future have it be uploaded and served by the
	// file-service with some security
	PhotoURL string `json:"photoURL"`

	// Type of the entity
	Type string `json:"type"`

	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// EntityCreateResponse is the output-object for creating an entity
type EntityCreateResponse struct {
	Created Entity `json:"created"`
}

// EntityDeleteRequest is the input-object for deleting an existing entity
type EntityDeleteRequest struct {
	// ID of the entity to delete
	ID string `json:"id"`

	// CaseID of the case to delete the new entity to
	CaseID string `json:"caseID"`
}

// EntityDeleteResponse is the output-object for updating an existing entity
type EntityDeleteResponse struct {
}

// EntityGetRequest is the input-object for getting an existing entity
type EntityGetRequest struct {
	// ID of the entity to get
	ID string `json:"id"`

	// CaseID of the case to get the entity for
	CaseID string `json:"caseID"`
}

// EntityGetResponse is the output-object for getting an existing entity
type EntityGetResponse struct {
	Entity Entity `json:"entity"`
}

// EntityListRequest is the input-object for deleting an existing entity
type EntityListRequest struct {
	// CaseID of the case to list the entities for
	CaseID string `json:"caseID"`
}

// EntityListResponse is the output-object for updating an existing entity
type EntityListResponse struct {
	Entities []Entity `json:"entities"`
}

// KeywordsAddRequest is the input-object for adding keywords to an object
type KeywordsAddRequest struct {
	// ID of the object to add keywords to
	ID string `json:"id"`

	// CaseID of the case for where the object belongs
	CaseID string `json:"caseID"`

	// The keywords to add
	Keywords []string `json:"keywords"`
}

// KeywordsAddResponse is the output-object for adding keywords to an object
type KeywordsAddResponse struct {
	// OK is set to true if the add was ok
	OK bool `json:"oK"`
}

// KeywordsRemoveRequest is the input-object for removing keywords from an object
type KeywordsRemoveRequest struct {
	// ID of the object to remove keywords to
	ID string `json:"id"`

	// CaseID of the case for where the object belongs
	CaseID string `json:"caseID"`

	// The keywords to remove
	Keywords []string `json:"keywords"`
}

// KeywordsRemoveResponse is the output-object for removing keywords from an object
type KeywordsRemoveResponse struct {
}

// EntityTypesRequest is the input-object for getting all entity-types
type EntityTypesRequest struct {
}

// EntityTypesResponse is the output-object for getting all entity-types
type EntityTypesResponse struct {
	// EntityTypes are the existing entity-types in the system
	EntityTypes []string `json:"entityTypes"`
}

// EntityUpdateRequest is the input-object for updating an existing entity
type EntityUpdateRequest struct {
	// ID of the entity to update
	ID string `json:"id"`

	// CaseID of the case to update the existing entity to
	CaseID string `json:"caseID"`

	// Title of the entity
	Title string `json:"title"`

	// PhotoURL of the entity. but in the future have it be uploaded and served by the
	// file-service with some security
	PhotoURL string `json:"photoURL"`

	// Type of the entity
	Type string `json:"type"`

	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// EntityUpdateResponse is the output-object for updating an existing entity
type EntityUpdateResponse struct {
	Updated Entity `json:"updated"`
}

// Event is an important happening that needs investigation.
type Event struct {
	Base

	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`

	// Desription of the event.
	Description string `json:"description"`

	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`

	// The keywords for the event
	Keywords []string `json:"keywords"`
}

// EventCreateRequest is the input-object for creating an event
type EventCreateRequest struct {
	// CaseID of the case to create the event for
	CaseID string `json:"caseID"`

	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`

	// Desription of the event.
	Description string `json:"description"`

	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventCreateResponse is the output-object for creating an event
type EventCreateResponse struct {
	Created Event `json:"created"`
}

// EventDeleteRequest is the input-object for deleting an existing event
type EventDeleteRequest struct {
	// ID of the event to Delete
	ID string `json:"id"`

	// CaseID of the event
	CaseID string `json:"caseID"`
}

// EventDeleteResponse is the output-object for deleting an existing event
type EventDeleteResponse struct {
}

// EventGetRequest is the input-object for getting an existing event
type EventGetRequest struct {
	// ID of the event to get
	ID string `json:"id"`

	// CaseID of the event
	CaseID string `json:"caseID"`
}

// EventGetResponse is the output-object for deleting an existing event
type EventGetResponse struct {
	Event Event `json:"event"`
}

// EventListRequest is the input-object for listing all existing events for a case
type EventListRequest struct {
	// CaseID to list the events for
	CaseID string `json:"caseID"`
}

// EventListResponse is the output-object for listing all existing events for a
// case
type EventListResponse struct {
	Events []Event `json:"events"`
}

// EventUpdateRequest is the input-object for updating an existing event
type EventUpdateRequest struct {
	// ID of the event to update
	ID string `json:"id"`

	// CaseID of the event
	CaseID string `json:"caseID"`

	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`

	// Desription of the event.
	Description string `json:"description"`

	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventUpdateResponse is the output-object for updating an existing event
type EventUpdateResponse struct {
	Updated Event `json:"updated"`
}

// FileDeleteRequest is the input-object for deleting a file
type FileDeleteRequest struct {
	// ID of the file to delete
	ID string `json:"id"`

	// CaseID of the case where the file to delete belongs
	CaseID string `json:"caseID"`
}

// FileDeleteResponse is the output-object for deleting a file
type FileDeleteResponse struct {
}

// FileNewRequest is the input-object for creating a new file
type FileNewRequest struct {
	// CaseID of the case to upload the file
	CaseID string `json:"caseID"`

	// Name of the file
	Name string `json:"name"`

	// Description of the file
	Description string `json:"description"`

	// Mime is the mime-type of the file (decided by frontend)
	Mime string `json:"mime"`

	// Data of the file (base64 encoded)
	Data string `json:"data"`
}

// FileNewResponse is the output-object for creating a new file
type FileNewResponse struct {
	New File `json:"new"`
}

// FileOpenRequest is the input-object for opening a file in a case
type FileOpenRequest struct {
	// ID of the file to open
	ID string `json:"id"`

	// CaseID of the case to open the file
	CaseID string `json:"caseID"`
}

// FileOpenResponse is the output-object for opening a file in a case
type FileOpenResponse struct {
	// Data contains the b64-encoded data for the file
	Data string `json:"data"`
}

// FileProcessRequest is the input-object for processing a file in a case
type FileProcessRequest struct {
	// ID of the file to process
	ID string `json:"id"`

	// CaseID of the case to process the file in
	CaseID string `json:"caseID"`
}

// FileProcessResponse is the output-object for processing a file in a case
type FileProcessResponse struct {
	Processed File `json:"processed"`
}

// FileProcessedRequest is the input-object for getting a processed file in a case
type FileProcessedRequest struct {
	// ID of the processed file
	ID string `json:"id"`

	// CaseID of the case to the processed file
	CaseID string `json:"caseID"`
}

// FileProcessedResponse is the output-object for get a processed file in a case
type FileProcessedResponse struct {
	ID string `json:"id"`

	Processed interface{} `json:"processed"`
}

// FileProcessesRequest is the input-object for getting a Processes file in a case
type FileProcessesRequest struct {
	// CaseID of the case to the get all the processes
	CaseID string `json:"caseID"`
}

// FileProcessesResponse is the output-object for get a Processes file in a case
type FileProcessesResponse struct {
	Processes interface{} `json:"processes"`
}

// FileUpdateRequest is the input-object for updating a files information
type FileUpdateRequest struct {
	// ID of the file to update
	ID string `json:"id"`

	// CaseID of the case where the file to update belongs
	CaseID string `json:"caseID"`

	// Description of the file
	Description string `json:"description"`
}

// FileUpdateResponse is the output-object for updating a files information
type FileUpdateResponse struct {
	Updated File `json:"updated"`
}

// Keyword represents a keyword in used for a case
type Keyword struct {
	// Name of the keyword
	Name string `json:"name"`

	// IDs of the events that holds the keyword
	EventIDs []string `json:"eventIDs"`

	// IDs of the persons that holds the keyword
	PersonIDs []string `json:"personIDs"`

	// IDs of the entities that holds the keyword
	EntityIDs []string `json:"entityIDs"`

	// IDs of the files that holds the keyword
	FileIDs []string `json:"fileIDs"`
}

// Person is a human related to a case
type Person struct {
	Base

	// FirstName(s) of the person
	FirstName string `json:"firstName"`

	// LastName(s) of the person
	LastName string `json:"lastName"`

	// EmailAddress of the person
	EmailAddress string `json:"emailAddress"`

	// PostalAddress of the person
	PostalAddress string `json:"postalAddress"`

	// WorkAddress of the person
	WorkAddress string `json:"workAddress"`

	// TelephoneNo of the person
	TelephoneNo string `json:"telephoneNo"`

	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`

	// The keywords for the person
	Keywords []string `json:"keywords"`
}

// Link is a link for an object between different objects
type Link struct {
	Base

	// From is the object that the link is from
	From interface{} `json:"from"`

	// Events that has been linked
	Events []Event `json:"events"`

	// Persons that has been linked
	Persons []Person `json:"persons"`

	// Entities that has been linked
	Entities []Entity `json:"entities"`

	// Files that has been linked
	Files []File `json:"files"`
}

// LinkAddRequest is the input-object for adding linked objects with a specific
// object
type LinkAddRequest struct {
	// ID is the ID of the link to add objects for
	ID string `json:"id"`

	// CaseID for the link
	CaseID string `json:"caseID"`

	// EventIDs of the events to be added to the link
	EventIDs []string `json:"eventIDs"`

	// PersonIDs of the persons to be added to the link
	PersonIDs []string `json:"personIDs"`

	// EntityIDs of the entities to be added to the link
	EntityIDs []string `json:"entityIDs"`

	// FileIDs of the files to be added to the link
	FileIDs []string `json:"fileIDs"`
}

// LinkAddResponse is the output-object for linking objects with an event
type LinkAddResponse struct {
	AddedLinks Link `json:"addedLinks"`
}

// LinkCreateRequest is the input-object for linking objects with to a specific
// object
type LinkCreateRequest struct {
	// CaseID for the object
	CaseID string `json:"caseID"`

	// FromID is the ID of the object to hold the link
	FromID string `json:"fromID"`

	// EventIDs of the events to be linked
	EventIDs []string `json:"eventIDs"`

	// PersonIDs of the persons to be linked
	PersonIDs []string `json:"personIDs"`

	// EntityIDs of the entitys to be linked
	EntityIDs []string `json:"entityIDs"`

	// FileIDs of the files to be linked
	FileIDs []string `json:"fileIDs"`

	// Bidirectional means that he link also should be created for the "ToID"
	Bidirectional bool `json:"bidirectional"`
}

// LinkCreateResponse is the output-object for linking objects
type LinkCreateResponse struct {
	Linked Link `json:"linked"`
}

// LinkDeleteRequest is the input-object for removing a linked object
type LinkDeleteRequest struct {
	// ID of the object to delete the link for
	ID string `json:"id"`

	// CaseID of the case where the link belongs
	CaseID string `json:"caseID"`
}

// LinkDeleteResponse is the output-object for removing a link
type LinkDeleteResponse struct {
}

// LinkGetRequest is the input-object for getting a links for an object
type LinkGetRequest struct {
	// ID of the object to get all links for
	ID string `json:"id"`

	// CaseID of the case where the link belongs
	CaseID string `json:"caseID"`
}

// LinkGetResponse is the output-object for getting a links for an object
type LinkGetResponse struct {
	Link Link `json:"link"`
}

// LinkRemoveRequest is the input-object for removing linked objects with a
// specific object
type LinkRemoveRequest struct {
	// ID is the ID of the link to remove objects for
	ID string `json:"id"`

	// CaseID for the link
	CaseID string `json:"caseID"`

	// EventIDs of the events to be removed from the link
	EventIDs []string `json:"eventIDs"`

	// PersonIDs of the persons to be removed from the link
	PersonIDs []string `json:"personIDs"`

	// EntityIDs of the entities to be removed from the link
	EntityIDs []string `json:"entityIDs"`

	// FileIDs of the files to be removed from the link
	FileIDs []string `json:"fileIDs"`
}

// LinkRemoveResponse is the output-object for removing linked objects from a link
// objects
type LinkRemoveResponse struct {
	RemovedLinks Link `json:"removedLinks"`
}

// PersonCreateRequest is the input-object for creating a person
type PersonCreateRequest struct {
	// CaseID of the case where the person should be created
	CaseID string `json:"caseID"`

	// FirstName(s) of the person
	FirstName string `json:"firstName"`

	// LastName(s) of the person
	LastName string `json:"lastName"`

	// EmailAddress of the person
	EmailAddress string `json:"emailAddress"`

	// PostalAddress of the person
	PostalAddress string `json:"postalAddress"`

	// WorkAddress of the person
	WorkAddress string `json:"workAddress"`

	// TelephoneNo of the person
	TelephoneNo string `json:"telephoneNo"`

	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// PersonCreateResponse is the output-object for creating a person
type PersonCreateResponse struct {
	Created Person `json:"created"`
}

// PersonDeleteRequest is the input-object for deleting an existing person
type PersonDeleteRequest struct {
	// ID of the person to delete
	ID string `json:"id"`

	// CaseID of the case where the person should be deleted
	CaseID string `json:"caseID"`
}

// PersonDeleteResponse is the output-object for deleting an existing person
type PersonDeleteResponse struct {
}

// PersonGetRequest is the input-object for getting an existing person
type PersonGetRequest struct {
	// ID of the person to get
	ID string `json:"id"`

	// CaseID of the case where the person should be gotten from
	CaseID string `json:"caseID"`
}

// PersonGetResponse is the output-object for getting an existing person
type PersonGetResponse struct {
	Person Person `json:"person"`
}

// PersonListRequest is the input-object for listing all persons for a case
type PersonListRequest struct {
	// CaseID of the case to listen all persons
	CaseID string `json:"caseID"`
}

// PersonListResponse is the output-object for listing all persons for a case
type PersonListResponse struct {
	Persons []Person `json:"persons"`
}

// PersonUpdateRequest is the input-object for updating an existing person
type PersonUpdateRequest struct {
	// ID of the person to update
	ID string `json:"id"`

	// CaseID of the case where the person should be updated
	CaseID string `json:"caseID"`

	// FirstName(s) of the person
	FirstName string `json:"firstName"`

	// LastName(s) of the person
	LastName string `json:"lastName"`

	// EmailAddress of the person
	EmailAddress string `json:"emailAddress"`

	// PostalAddress of the person
	PostalAddress string `json:"postalAddress"`

	// WorkAddress of the person
	WorkAddress string `json:"workAddress"`

	// TelephoneNo of the person
	TelephoneNo string `json:"telephoneNo"`

	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// PersonUpdateResponse is the output-object for updating an existing person
type PersonUpdateResponse struct {
	Updated Person `json:"updated"`
}

// ProcessAbortRequest is the input-object for aborting a processing-job
type ProcessAbortRequest struct {
	// ID of the processing-job to abort
	ID string `json:"id"`

	// CaseID of the case the processing-job belongs to
	CaseID string `json:"caseID"`
}

// ProcessAbortResponse is the output-object for aborting a processing-job
type ProcessAbortResponse struct {
	Aborted Process `json:"aborted"`
}

// ProcessJobsRequest is the input-object for getting all processing-jobs for a
// case
type ProcessJobsRequest struct {
	// CaseID of the case to get the processing-jobs for
	CaseID string `json:"caseID"`
}

// ProcessJobsResponse is the output-object for getting all processing-jobs for a
// case
type ProcessJobsResponse struct {
	Processes []Process `json:"processes"`
}

// ProcessPauseRequest is the input-object for pausing a processing-job
type ProcessPauseRequest struct {
	// ID of the processing-job to pause
	ID string `json:"id"`

	// CaseID of the case the processing-job belongs to
	CaseID string `json:"caseID"`
}

// ProcessPauseResponse is the output-object for pausing a processing-job
type ProcessPauseResponse struct {
	Paused Process `json:"paused"`
}

// ProcessStartRequest is the input-object for starting a processing-job
type ProcessStartRequest struct {
	// CaseID of the case to start the processing for
	CaseID string `json:"caseID"`

	// FileIDs of the files to process
	FileIDs []string `json:"fileIDs"`
}

// ProcessStartResponse is the output-object for starting a processing-job
type ProcessStartResponse struct {
	Started Process `json:"started"`
}

// SearchTextRequest is the input-object for searching items
type SearchTextRequest struct {
	// ID for the case to search in
	CaseID string `json:"caseID"`

	// Text to search for
	Text string `json:"text"`
}

// SearchTextResponse is the output-object for searching items
type SearchTextResponse struct {
	Events []Event `json:"events"`

	Entities []Entity `json:"entities"`

	Persons []Person `json:"persons"`

	Files []File `json:"files"`

	Processed interface{} `json:"processed"`
}

// SearchTimespanRequest is the input-object for searching items
type SearchTimespanRequest struct {
	// ID for the case to search in
	CaseID string `json:"caseID"`

	// FromDate is the unix-timestamp of where the timespan starts
	FromDate int64 `json:"fromDate"`

	// ToDate is the unix-timestamp of where the timespan finishes
	ToDate int64 `json:"toDate"`
}

// SearchTimespanResponse is the output-object for searching items
type SearchTimespanResponse struct {
	Events []Event `json:"events"`
}

// TestCreateUserRequest is the input-object for creating a test-user
type TestCreateUserRequest struct {
	// Name of the user to create
	Name string `json:"name"`

	// ID of the user to create
	ID string `json:"id"`

	// Email of the user to create
	Email string `json:"email"`

	// Password for the new user
	Password string `json:"password"`

	// Secret for using the test-service
	Secret string `json:"secret,omitempty"`
}

// TestCreateUserResponse is the output-object for creating a test-user
type TestCreateUserResponse struct {
	// Token for the created user
	Token string `json:"token"`
}

// TestDeleteUserRequest is the input-object for deleting a test-user
type TestDeleteUserRequest struct {
	// ID of the user to delete
	ID string `json:"id"`

	// Secret for using the test-service
	Secret string `json:"secret,omitempty"`
}

// TestDeleteUserResponse is the output-object for deleting a test-user
type TestDeleteUserResponse struct {
}

// User holds information for a user in the timeline-investigator
type User struct {
	DisplayName string `json:"displayName"`

	Email string `json:"email"`

	PhoneNumber string `json:"phoneNumber"`

	PhotoURL string `json:"photoURL"`

	ProviderID string `json:"providerID"`

	UID string `json:"uID"`
}
