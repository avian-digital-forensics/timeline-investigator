// Code generated by oto; DO NOT EDIT.

package api

import (
	"github.com/pacedotdev/oto/otohttp"
	"log"

	http "net/http"

	context "context"
)

// CaseService is the API to handle cases
type CaseService interface {
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// Delete deletes the specified case
	Delete(context.Context, CaseDeleteRequest) (*CaseDeleteResponse, error)
	// Get returns the requested case
	Get(context.Context, CaseGetRequest) (*CaseGetResponse, error)
	// Keywords lists all the keywords for the case
	Keywords(context.Context, CaseKeywordsRequest) (*CaseKeywordsResponse, error)
	// List the cases for a specified user
	List(context.Context, CaseListRequest) (*CaseListResponse, error)
	// New creates a new case
	New(context.Context, CaseNewRequest) (*CaseNewResponse, error)
	// Update updates the specified case
	Update(context.Context, CaseUpdateRequest) (*CaseUpdateResponse, error)
}

// EntityService is the API to handle entities
type EntityService interface {
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// Create creates a new entity
	Create(context.Context, EntityCreateRequest) (*EntityCreateResponse, error)
	// Delete deletes an existing entity
	Delete(context.Context, EntityDeleteRequest) (*EntityDeleteResponse, error)
	// Get the specified entity
	Get(context.Context, EntityGetRequest) (*EntityGetResponse, error)
	// KeywordsAdd to an entity
	KeywordsAdd(context.Context, KeywordsAddRequest) (*KeywordsAddResponse, error)
	// KeywordsRemove from an entity
	KeywordsRemove(context.Context, KeywordsRemoveRequest) (*KeywordsRemoveResponse, error)
	// List all entities
	List(context.Context, EntityListRequest) (*EntityListResponse, error)
	// Types returns the existing entity-types
	Types(context.Context, EntityTypesRequest) (*EntityTypesResponse, error)
	// Update updates an existing entity
	Update(context.Context, EntityUpdateRequest) (*EntityUpdateResponse, error)
}

// EventService is the API to handle events
type EventService interface {
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// Create creates a new event
	Create(context.Context, EventCreateRequest) (*EventCreateResponse, error)
	// Delete deletes an existing event
	Delete(context.Context, EventDeleteRequest) (*EventDeleteResponse, error)
	// Get the specified event
	Get(context.Context, EventGetRequest) (*EventGetResponse, error)
	// KeywordsAdd to an event
	KeywordsAdd(context.Context, KeywordsAddRequest) (*KeywordsAddResponse, error)
	// KeywordsRemove from an event
	KeywordsRemove(context.Context, KeywordsRemoveRequest) (*KeywordsRemoveResponse, error)
	// List all events
	List(context.Context, EventListRequest) (*EventListResponse, error)
	// Update updates an existing event
	Update(context.Context, EventUpdateRequest) (*EventUpdateResponse, error)
}

// FileService is the API for handling files
type FileService interface {
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// Delete deletes the specified file
	Delete(context.Context, FileDeleteRequest) (*FileDeleteResponse, error)
	// KeywordsAdd to a file
	KeywordsAdd(context.Context, KeywordsAddRequest) (*KeywordsAddResponse, error)
	// KeywordsRemove from a file
	KeywordsRemove(context.Context, KeywordsRemoveRequest) (*KeywordsRemoveResponse, error)
	// New uploads a file to the backend
	New(context.Context, FileNewRequest) (*FileNewResponse, error)
	// Open opens a file
	Open(context.Context, FileOpenRequest) (*FileOpenResponse, error)
	// Process processes a file
	Process(context.Context, FileProcessRequest) (*FileProcessResponse, error)
	// Processed gets information for a processed file
	Processed(context.Context, FileProcessedRequest) (*FileProcessedResponse, error)
	// Processes gets information for all proccesed files in the specified case
	Processes(context.Context, FileProcessesRequest) (*FileProcessesResponse, error)
	// Update updates the information for a file
	Update(context.Context, FileUpdateRequest) (*FileUpdateResponse, error)
}

// LinkService is a API for creating links between objects
type LinkService interface {
	// Add adds specified links to an object
	Add(context.Context, LinkAddRequest) (*LinkAddResponse, error)
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// Create creates a links for an object
	Create(context.Context, LinkCreateRequest) (*LinkCreateResponse, error)
	// Delete deletes all links to the specified object
	Delete(context.Context, LinkDeleteRequest) (*LinkDeleteResponse, error)
	// Get gets an object with its links
	Get(context.Context, LinkGetRequest) (*LinkGetResponse, error)
	// Remove removes specified links from an object
	Remove(context.Context, LinkRemoveRequest) (*LinkRemoveResponse, error)
}

// PersonService is the API to handle entities
type PersonService interface {
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// Create creates a new person
	Create(context.Context, PersonCreateRequest) (*PersonCreateResponse, error)
	// Delete deletes an existing person
	Delete(context.Context, PersonDeleteRequest) (*PersonDeleteResponse, error)
	// Get the specified person
	Get(context.Context, PersonGetRequest) (*PersonGetResponse, error)
	// KeywordsAdd to a person
	KeywordsAdd(context.Context, KeywordsAddRequest) (*KeywordsAddResponse, error)
	// KeywordsRemove from a person
	KeywordsRemove(context.Context, KeywordsRemoveRequest) (*KeywordsRemoveResponse, error)
	// List all entities for a case
	List(context.Context, PersonListRequest) (*PersonListResponse, error)
	// Update updates an existing person
	Update(context.Context, PersonUpdateRequest) (*PersonUpdateResponse, error)
}

// SearchService is the API to handle searches in the Timeline-Investigator
type SearchService interface {
	// Authenticate is a middleware in the http-handler
	Authenticate(context.Context, *http.Request) (context.Context, error)
	// SearchWithText returns data in the case that is related to the text
	SearchWithText(context.Context, SearchTextRequest) (*SearchTextResponse, error)
	// SearchWithTimespan returns events from the selected timespan
	SearchWithTimespan(context.Context, SearchTimespanRequest) (*SearchTimespanResponse, error)
}

// TestService is used for testing-purposes
type TestService interface {
	// CreateUser creates a test-user in Firebase
	CreateUser(context.Context, TestCreateUserRequest) (*TestCreateUserResponse, error)
	// DeleteUser deletes a test-user in Firebase
	DeleteUser(context.Context, TestDeleteUserRequest) (*TestDeleteUserResponse, error)
}

type caseServiceServer struct {
	server      *otohttp.Server
	caseService CaseService
	test        bool
}

// Register adds the CaseService to the otohttp.Server.
func RegisterCaseService(server *otohttp.Server, caseService CaseService) {
	handler := &caseServiceServer{
		server:      server,
		caseService: caseService,
	}

	server.Register("CaseService", "Delete", handler.handleDelete)
	server.Register("CaseService", "Get", handler.handleGet)
	server.Register("CaseService", "Keywords", handler.handleKeywords)
	server.Register("CaseService", "List", handler.handleList)
	server.Register("CaseService", "New", handler.handleNew)
	server.Register("CaseService", "Update", handler.handleUpdate)
}

func (s *caseServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	var request CaseDeleteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.caseService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.caseService.Delete(ctx, request)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *caseServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	var request CaseGetRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.caseService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.caseService.Get(ctx, request)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *caseServiceServer) handleKeywords(w http.ResponseWriter, r *http.Request) {
	var request CaseKeywordsRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.caseService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.caseService.Keywords(ctx, request)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *caseServiceServer) handleList(w http.ResponseWriter, r *http.Request) {
	var request CaseListRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.caseService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.caseService.List(ctx, request)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *caseServiceServer) handleNew(w http.ResponseWriter, r *http.Request) {
	var request CaseNewRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.caseService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.caseService.New(ctx, request)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *caseServiceServer) handleUpdate(w http.ResponseWriter, r *http.Request) {
	var request CaseUpdateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.caseService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.caseService.Update(ctx, request)
	if err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("CaseService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type entityServiceServer struct {
	server        *otohttp.Server
	entityService EntityService
	test          bool
}

// Register adds the EntityService to the otohttp.Server.
func RegisterEntityService(server *otohttp.Server, entityService EntityService) {
	handler := &entityServiceServer{
		server:        server,
		entityService: entityService,
	}

	server.Register("EntityService", "Create", handler.handleCreate)
	server.Register("EntityService", "Delete", handler.handleDelete)
	server.Register("EntityService", "Get", handler.handleGet)
	server.Register("EntityService", "KeywordsAdd", handler.handleKeywordsAdd)
	server.Register("EntityService", "KeywordsRemove", handler.handleKeywordsRemove)
	server.Register("EntityService", "List", handler.handleList)
	server.Register("EntityService", "Types", handler.handleTypes)
	server.Register("EntityService", "Update", handler.handleUpdate)
}

func (s *entityServiceServer) handleCreate(w http.ResponseWriter, r *http.Request) {
	var request EntityCreateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.Create(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	var request EntityDeleteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.Delete(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	var request EntityGetRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.Get(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleKeywordsAdd(w http.ResponseWriter, r *http.Request) {
	var request KeywordsAddRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.KeywordsAdd(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleKeywordsRemove(w http.ResponseWriter, r *http.Request) {
	var request KeywordsRemoveRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.KeywordsRemove(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleList(w http.ResponseWriter, r *http.Request) {
	var request EntityListRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.List(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleTypes(w http.ResponseWriter, r *http.Request) {
	var request EntityTypesRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.Types(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *entityServiceServer) handleUpdate(w http.ResponseWriter, r *http.Request) {
	var request EntityUpdateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.entityService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.entityService.Update(ctx, request)
	if err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EntityService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type eventServiceServer struct {
	server       *otohttp.Server
	eventService EventService
	test         bool
}

// Register adds the EventService to the otohttp.Server.
func RegisterEventService(server *otohttp.Server, eventService EventService) {
	handler := &eventServiceServer{
		server:       server,
		eventService: eventService,
	}

	server.Register("EventService", "Create", handler.handleCreate)
	server.Register("EventService", "Delete", handler.handleDelete)
	server.Register("EventService", "Get", handler.handleGet)
	server.Register("EventService", "KeywordsAdd", handler.handleKeywordsAdd)
	server.Register("EventService", "KeywordsRemove", handler.handleKeywordsRemove)
	server.Register("EventService", "List", handler.handleList)
	server.Register("EventService", "Update", handler.handleUpdate)
}

func (s *eventServiceServer) handleCreate(w http.ResponseWriter, r *http.Request) {
	var request EventCreateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.Create(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *eventServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	var request EventDeleteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.Delete(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *eventServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	var request EventGetRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.Get(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *eventServiceServer) handleKeywordsAdd(w http.ResponseWriter, r *http.Request) {
	var request KeywordsAddRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.KeywordsAdd(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *eventServiceServer) handleKeywordsRemove(w http.ResponseWriter, r *http.Request) {
	var request KeywordsRemoveRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.KeywordsRemove(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *eventServiceServer) handleList(w http.ResponseWriter, r *http.Request) {
	var request EventListRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.List(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *eventServiceServer) handleUpdate(w http.ResponseWriter, r *http.Request) {
	var request EventUpdateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.eventService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.eventService.Update(ctx, request)
	if err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("EventService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type fileServiceServer struct {
	server      *otohttp.Server
	fileService FileService
	test        bool
}

// Register adds the FileService to the otohttp.Server.
func RegisterFileService(server *otohttp.Server, fileService FileService) {
	handler := &fileServiceServer{
		server:      server,
		fileService: fileService,
	}

	server.Register("FileService", "Delete", handler.handleDelete)
	server.Register("FileService", "KeywordsAdd", handler.handleKeywordsAdd)
	server.Register("FileService", "KeywordsRemove", handler.handleKeywordsRemove)
	server.Register("FileService", "New", handler.handleNew)
	server.Register("FileService", "Open", handler.handleOpen)
	server.Register("FileService", "Process", handler.handleProcess)
	server.Register("FileService", "Processed", handler.handleProcessed)
	server.Register("FileService", "Processes", handler.handleProcesses)
	server.Register("FileService", "Update", handler.handleUpdate)
}

func (s *fileServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	var request FileDeleteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.Delete(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleKeywordsAdd(w http.ResponseWriter, r *http.Request) {
	var request KeywordsAddRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.KeywordsAdd(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleKeywordsRemove(w http.ResponseWriter, r *http.Request) {
	var request KeywordsRemoveRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.KeywordsRemove(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleNew(w http.ResponseWriter, r *http.Request) {
	var request FileNewRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.New(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleOpen(w http.ResponseWriter, r *http.Request) {
	var request FileOpenRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.Open(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleProcess(w http.ResponseWriter, r *http.Request) {
	var request FileProcessRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.Process(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleProcessed(w http.ResponseWriter, r *http.Request) {
	var request FileProcessedRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.Processed(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleProcesses(w http.ResponseWriter, r *http.Request) {
	var request FileProcessesRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.Processes(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *fileServiceServer) handleUpdate(w http.ResponseWriter, r *http.Request) {
	var request FileUpdateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.fileService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.fileService.Update(ctx, request)
	if err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("FileService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type linkServiceServer struct {
	server      *otohttp.Server
	linkService LinkService
	test        bool
}

// Register adds the LinkService to the otohttp.Server.
func RegisterLinkService(server *otohttp.Server, linkService LinkService) {
	handler := &linkServiceServer{
		server:      server,
		linkService: linkService,
	}
	server.Register("LinkService", "Add", handler.handleAdd)

	server.Register("LinkService", "Create", handler.handleCreate)
	server.Register("LinkService", "Delete", handler.handleDelete)
	server.Register("LinkService", "Get", handler.handleGet)
	server.Register("LinkService", "Remove", handler.handleRemove)
}

func (s *linkServiceServer) handleAdd(w http.ResponseWriter, r *http.Request) {
	var request LinkAddRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.linkService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.linkService.Add(ctx, request)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *linkServiceServer) handleCreate(w http.ResponseWriter, r *http.Request) {
	var request LinkCreateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.linkService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.linkService.Create(ctx, request)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *linkServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	var request LinkDeleteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.linkService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.linkService.Delete(ctx, request)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *linkServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	var request LinkGetRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.linkService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.linkService.Get(ctx, request)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *linkServiceServer) handleRemove(w http.ResponseWriter, r *http.Request) {
	var request LinkRemoveRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.linkService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.linkService.Remove(ctx, request)
	if err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("LinkService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type personServiceServer struct {
	server        *otohttp.Server
	personService PersonService
	test          bool
}

// Register adds the PersonService to the otohttp.Server.
func RegisterPersonService(server *otohttp.Server, personService PersonService) {
	handler := &personServiceServer{
		server:        server,
		personService: personService,
	}

	server.Register("PersonService", "Create", handler.handleCreate)
	server.Register("PersonService", "Delete", handler.handleDelete)
	server.Register("PersonService", "Get", handler.handleGet)
	server.Register("PersonService", "KeywordsAdd", handler.handleKeywordsAdd)
	server.Register("PersonService", "KeywordsRemove", handler.handleKeywordsRemove)
	server.Register("PersonService", "List", handler.handleList)
	server.Register("PersonService", "Update", handler.handleUpdate)
}

func (s *personServiceServer) handleCreate(w http.ResponseWriter, r *http.Request) {
	var request PersonCreateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.Create(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *personServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	var request PersonDeleteRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.Delete(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *personServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	var request PersonGetRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.Get(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *personServiceServer) handleKeywordsAdd(w http.ResponseWriter, r *http.Request) {
	var request KeywordsAddRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.KeywordsAdd(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *personServiceServer) handleKeywordsRemove(w http.ResponseWriter, r *http.Request) {
	var request KeywordsRemoveRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.KeywordsRemove(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *personServiceServer) handleList(w http.ResponseWriter, r *http.Request) {
	var request PersonListRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.List(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *personServiceServer) handleUpdate(w http.ResponseWriter, r *http.Request) {
	var request PersonUpdateRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.personService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.personService.Update(ctx, request)
	if err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("PersonService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type searchServiceServer struct {
	server        *otohttp.Server
	searchService SearchService
	test          bool
}

// Register adds the SearchService to the otohttp.Server.
func RegisterSearchService(server *otohttp.Server, searchService SearchService) {
	handler := &searchServiceServer{
		server:        server,
		searchService: searchService,
	}

	server.Register("SearchService", "SearchWithText", handler.handleSearchWithText)
	server.Register("SearchService", "SearchWithTimespan", handler.handleSearchWithTimespan)
}

func (s *searchServiceServer) handleSearchWithText(w http.ResponseWriter, r *http.Request) {
	var request SearchTextRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.searchService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.searchService.SearchWithText(ctx, request)
	if err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *searchServiceServer) handleSearchWithTimespan(w http.ResponseWriter, r *http.Request) {
	var request SearchTimespanRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx, err := s.searchService.Authenticate(r.Context(), r)
	if err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.searchService.SearchWithTimespan(ctx, request)
	if err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("SearchService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

type testServiceServer struct {
	server      *otohttp.Server
	testService TestService
	test        bool
}

// Register adds the TestService to the otohttp.Server.
func RegisterTestService(server *otohttp.Server, testService TestService) {
	handler := &testServiceServer{
		server:      server,
		testService: testService,
	}
	server.Register("TestService", "CreateUser", handler.handleCreateUser)
	server.Register("TestService", "DeleteUser", handler.handleDeleteUser)
}

func (s *testServiceServer) handleCreateUser(w http.ResponseWriter, r *http.Request) {
	var request TestCreateUserRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("TestService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx := r.Context()
	response, err := s.testService.CreateUser(ctx, request)
	if err != nil {
		log.Printf("TestService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("TestService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *testServiceServer) handleDeleteUser(w http.ResponseWriter, r *http.Request) {
	var request TestDeleteUserRequest
	if err := otohttp.Decode(r, &request); err != nil {
		log.Printf("TestService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	ctx := r.Context()
	response, err := s.testService.DeleteUser(ctx, request)
	if err != nil {
		log.Printf("TestService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		log.Printf("TestService : %s", err.Error())
		s.server.OnErr(w, r, err)
		return
	}
}

// Base model for the database
type Base struct {
	// ID is the identifier for the object
	ID string `json:"id"`
	// CreatedAt - when the object was created
	CreatedAt int64 `json:"createdAt"`
	// UpdatedAt - when the object was updated
	UpdatedAt int64 `json:"updatedAt"`
	// DeletedAt - when the object was deleted
	DeletedAt int64 `json:"deletedAt"`
}

// File holds information about an uploaded file
type File struct {
	Base
	// Name of the file
	Name string `json:"name"`
	// Mime is the mime-type of the file
	Mime string `json:"mime"`
	// Description of the file
	Description string `json:"description"`
	// Path to where the file is stored
	Path string `json:"path"`
	// Size of the file in bytes
	Size int `json:"size"`
	// ProcessedAt is the unix-timestamp for when (if) the item was processed
	ProcessedAt int64 `json:"processedAt"`
	// The keywords for the file
	Keywords []string `json:"keywords"`
}

// Process holds information about a job that processes data to app
type Process struct {
	Base
	// Files for the process
	Files []string `json:"files"`
}

// Case is an object to hold data for a specific investigation
type Case struct {
	Base
	// CreatorID is the user-id of the user who created the case (super admin)
	CreatorID string `json:"creatorID"`
	// Name of the case
	Name string `json:"name"`
	// Description of the case
	Description string `json:"description"`
	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
	// Investigators of the case (users who has access to the case)
	Investigators []string `json:"investigators"`
	// Files that exists in the case
	Files []File `json:"files"`
	// Processes that exists in the case
	Processes []Process `json:"processes"`
}

// CaseDeleteRequest is the input-object for deleting an existing case
type CaseDeleteRequest struct {
	// ID of the case to delete
	ID string `json:"id"`
}

// CaseDeleteResponse is the output-object for deleting an existing case
type CaseDeleteResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// CaseGetRequest is the input-object for getting a specified case
type CaseGetRequest struct {
	// ID of the case to get
	ID string `json:"id"`
}

// CaseGetResponse is the output-object for getting a specified case
type CaseGetResponse struct {
	Case Case `json:"case"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// CaseKeywordsRequest is the input-object for listing keywords for a case
type CaseKeywordsRequest struct {
	// ID for the case to get the keywords for
	ID string `json:"id"`
}

// CaseKeywordsResponse is the output-object for listing keywords for a case
type CaseKeywordsResponse struct {
	// Existing keywords in the case
	Keywords []string `json:"keywords"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// CaseListRequest is the input-object for listing cases for a specified user
type CaseListRequest struct {
	// UserID of the user to list cases for
	UserID string `json:"userID"`
}

// CaseListResponse is the output-object for listing cases for a specified user
type CaseListResponse struct {
	Cases []Case `json:"cases"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// CaseNewRequest is the input-object for creating a new case
type CaseNewRequest struct {
	// Name of the case
	Name string `json:"name"`
	// description of the case to create
	Description string `json:"description"`
	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
}

// CaseNewResponse is the output-object for creating a new case
type CaseNewResponse struct {
	New Case `json:"new"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// CaseUpdateRequest is the input-object for updating an existing case
type CaseUpdateRequest struct {
	// ID of the case to update
	ID string `json:"id"`
	// Name of the case
	Name string `json:"name"`
	// description of the case to create
	Description string `json:"description"`
	// FromDate is the unix-date for the start of the primary timespan for the case
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-date for the end of the primary timespan for the case
	ToDate int64 `json:"toDate"`
}

// CaseUpdateResponse is the output-object for updating an existing case
type CaseUpdateResponse struct {
	Updated Case `json:"updated"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// Entity is an object that can be of different types. For example, organization or
// location
type Entity struct {
	Base
	// Title of the entity
	Title string `json:"title"`
	// PhotoURL of the entity. but in the future have it be uploaded and served by the
	// file-service with some security
	PhotoURL string `json:"photoURL"`
	// Type of the entity
	Type string `json:"type"`
	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
	// The keywords for the entity
	Keywords []string `json:"keywords"`
}

// EntityCreateRequest is the input-object for creating an entity
type EntityCreateRequest struct {
	// CaseID of the case to create the new entity to
	CaseID string `json:"caseID"`
	// Title of the entity
	Title string `json:"title"`
	// PhotoURL of the entity. but in the future have it be uploaded and served by the
	// file-service with some security
	PhotoURL string `json:"photoURL"`
	// Type of the entity
	Type string `json:"type"`
	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// EntityCreateResponse is the output-object for creating an entity
type EntityCreateResponse struct {
	Created Entity `json:"created"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EntityDeleteRequest is the input-object for deleting an existing entity
type EntityDeleteRequest struct {
	// ID of the entity to delete
	ID string `json:"id"`
	// CaseID of the case to delete the new entity to
	CaseID string `json:"caseID"`
}

// EntityDeleteResponse is the output-object for updating an existing entity
type EntityDeleteResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EntityGetRequest is the input-object for getting an existing entity
type EntityGetRequest struct {
	// ID of the entity to get
	ID string `json:"id"`
	// CaseID of the case to get the entity for
	CaseID string `json:"caseID"`
}

// EntityGetResponse is the output-object for getting an existing entity
type EntityGetResponse struct {
	Entity Entity `json:"entity"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EntityListRequest is the input-object for deleting an existing entity
type EntityListRequest struct {
	// CaseID of the case to list the entities for
	CaseID string `json:"caseID"`
}

// EntityListResponse is the output-object for updating an existing entity
type EntityListResponse struct {
	Entities []Entity `json:"entities"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// KeywordsAddRequest is the input-object for adding keywords to an object
type KeywordsAddRequest struct {
	// ID of the object to add keywords to
	ID string `json:"id"`
	// CaseID of the case for where the object belongs
	CaseID string `json:"caseID"`
	// The keywords to add
	Keywords []string `json:"keywords"`
}

// KeywordsAddResponse is the output-object for adding keywords to an object
type KeywordsAddResponse struct {
	// OK is set to true if the add was ok
	OK bool `json:"oK"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// KeywordsRemoveRequest is the input-object for removing keywords from an object
type KeywordsRemoveRequest struct {
	// ID of the object to remove keywords to
	ID string `json:"id"`
	// CaseID of the case for where the object belongs
	CaseID string `json:"caseID"`
	// The keywords to remove
	Keywords []string `json:"keywords"`
}

// KeywordsRemoveResponse is the output-object for removing keywords from an object
type KeywordsRemoveResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EntityTypesRequest is the input-object for getting all entity-types
type EntityTypesRequest struct {
}

// EntityTypesResponse is the output-object for getting all entity-types
type EntityTypesResponse struct {
	// EntityTypes are the existing entity-types in the system
	EntityTypes []string `json:"entityTypes"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EntityUpdateRequest is the input-object for updating an existing entity
type EntityUpdateRequest struct {
	// ID of the entity to update
	ID string `json:"id"`
	// CaseID of the case to update the existing entity to
	CaseID string `json:"caseID"`
	// Title of the entity
	Title string `json:"title"`
	// PhotoURL of the entity. but in the future have it be uploaded and served by the
	// file-service with some security
	PhotoURL string `json:"photoURL"`
	// Type of the entity
	Type string `json:"type"`
	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// EntityUpdateResponse is the output-object for updating an existing entity
type EntityUpdateResponse struct {
	Updated Entity `json:"updated"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// Event is an important happening that needs investigation.
type Event struct {
	Base
	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`
	// Desription of the event.
	Description string `json:"description"`
	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
	// The keywords for the event
	Keywords []string `json:"keywords"`
}

// EventCreateRequest is the input-object for creating an event
type EventCreateRequest struct {
	// CaseID of the case to create the event for
	CaseID string `json:"caseID"`
	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`
	// Desription of the event.
	Description string `json:"description"`
	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventCreateResponse is the output-object for creating an event
type EventCreateResponse struct {
	Created Event `json:"created"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EventDeleteRequest is the input-object for deleting an existing event
type EventDeleteRequest struct {
	// ID of the event to Delete
	ID string `json:"id"`
	// CaseID of the event
	CaseID string `json:"caseID"`
}

// EventDeleteResponse is the output-object for deleting an existing event
type EventDeleteResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EventGetRequest is the input-object for getting an existing event
type EventGetRequest struct {
	// ID of the event to get
	ID string `json:"id"`
	// CaseID of the event
	CaseID string `json:"caseID"`
}

// EventGetResponse is the output-object for deleting an existing event
type EventGetResponse struct {
	Event Event `json:"event"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EventListRequest is the input-object for listing all existing events for a case
type EventListRequest struct {
	// CaseID to list the events for
	CaseID string `json:"caseID"`
}

// EventListResponse is the output-object for listing all existing events for a
// case
type EventListResponse struct {
	Events []Event `json:"events"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// EventUpdateRequest is the input-object for updating an existing event
type EventUpdateRequest struct {
	// ID of the event to update
	ID string `json:"id"`
	// CaseID of the event
	CaseID string `json:"caseID"`
	// Set the importance of the event, defined by a number between 1 - 5.
	Importance int `json:"importance"`
	// Desription of the event.
	Description string `json:"description"`
	// FromDate is the unix-timestamp of when the event started
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-timestamp of when the event finished
	ToDate int64 `json:"toDate"`
}

// EventUpdateResponse is the output-object for updating an existing event
type EventUpdateResponse struct {
	Updated Event `json:"updated"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileDeleteRequest is the input-object for deleting a file
type FileDeleteRequest struct {
	// ID of the file to delete
	ID string `json:"id"`
	// CaseID of the case where the file to delete belongs
	CaseID string `json:"caseID"`
}

// FileDeleteResponse is the output-object for deleting a file
type FileDeleteResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileNewRequest is the input-object for creating a new file
type FileNewRequest struct {
	// CaseID of the case to upload the file
	CaseID string `json:"caseID"`
	// Name of the file
	Name string `json:"name"`
	// Description of the file
	Description string `json:"description"`
	// Mime is the mime-type of the file (decided by frontend)
	Mime string `json:"mime"`
	// Data of the file (base64 encoded)
	Data string `json:"data"`
}

// FileNewResponse is the output-object for creating a new file
type FileNewResponse struct {
	New File `json:"new"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileOpenRequest is the input-object for opening a file in a case
type FileOpenRequest struct {
	// ID of the file to open
	ID string `json:"id"`
	// CaseID of the case to open the file
	CaseID string `json:"caseID"`
}

// FileOpenResponse is the output-object for opening a file in a case
type FileOpenResponse struct {
	// Data contains the b64-encoded data for the file
	Data string `json:"data"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileProcessRequest is the input-object for processing a file in a case
type FileProcessRequest struct {
	// ID of the file to process
	ID string `json:"id"`
	// CaseID of the case to process the file in
	CaseID string `json:"caseID"`
}

// FileProcessResponse is the output-object for processing a file in a case
type FileProcessResponse struct {
	Processed File `json:"processed"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileProcessedRequest is the input-object for getting a processed file in a case
type FileProcessedRequest struct {
	// ID of the processed file
	ID string `json:"id"`
	// CaseID of the case to the processed file
	CaseID string `json:"caseID"`
}

// FileProcessedResponse is the output-object for get a processed file in a case
type FileProcessedResponse struct {
	ID        string      `json:"id"`
	Processed interface{} `json:"processed"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileProcessesRequest is the input-object for getting a Processes file in a case
type FileProcessesRequest struct {
	// CaseID of the case to the get all the processes
	CaseID string `json:"caseID"`
}

// FileProcessesResponse is the output-object for get a Processes file in a case
type FileProcessesResponse struct {
	Processes interface{} `json:"processes"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// FileUpdateRequest is the input-object for updating a files information
type FileUpdateRequest struct {
	// ID of the file to update
	ID string `json:"id"`
	// CaseID of the case where the file to update belongs
	CaseID string `json:"caseID"`
	// Description of the file
	Description string `json:"description"`
}

// FileUpdateResponse is the output-object for updating a files information
type FileUpdateResponse struct {
	Updated File `json:"updated"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// Keyword represents a keyword in used for a case
type Keyword struct {
	// Name of the keyword
	Name string `json:"name"`
	// IDs of the events that holds the keyword
	EventIDs []string `json:"eventIDs"`
	// IDs of the persons that holds the keyword
	PersonIDs []string `json:"personIDs"`
	// IDs of the entities that holds the keyword
	EntityIDs []string `json:"entityIDs"`
	// IDs of the files that holds the keyword
	FileIDs []string `json:"fileIDs"`
}

// Person is a human related to a case
type Person struct {
	Base
	// FirstName(s) of the person
	FirstName string `json:"firstName"`
	// LastName(s) of the person
	LastName string `json:"lastName"`
	// EmailAddress of the person
	EmailAddress string `json:"emailAddress"`
	// PostalAddress of the person
	PostalAddress string `json:"postalAddress"`
	// WorkAddress of the person
	WorkAddress string `json:"workAddress"`
	// TelephoneNo of the person
	TelephoneNo string `json:"telephoneNo"`
	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
	// The keywords for the person
	Keywords []string `json:"keywords"`
}

// Link is a link for an object between different objects
type Link struct {
	Base
	// From is the object that the link is from
	From interface{} `json:"from"`
	// Events that has been linked
	Events []Event `json:"events"`
	// Persons that has been linked
	Persons []Person `json:"persons"`
	// Entities that has been linked
	Entities []Entity `json:"entities"`
	// Files that has been linked
	Files []File `json:"files"`
}

// LinkAddRequest is the input-object for adding linked objects with a specific
// object
type LinkAddRequest struct {
	// ID is the ID of the link to add objects for
	ID string `json:"id"`
	// CaseID for the link
	CaseID string `json:"caseID"`
	// EventIDs of the events to be added to the link
	EventIDs []string `json:"eventIDs"`
	// PersonIDs of the persons to be added to the link
	PersonIDs []string `json:"personIDs"`
	// EntityIDs of the entities to be added to the link
	EntityIDs []string `json:"entityIDs"`
	// FileIDs of the files to be added to the link
	FileIDs []string `json:"fileIDs"`
}

// LinkAddResponse is the output-object for linking objects with an event
type LinkAddResponse struct {
	AddedLinks Link `json:"addedLinks"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// LinkCreateRequest is the input-object for linking objects with to a specific
// object
type LinkCreateRequest struct {
	// CaseID for the object
	CaseID string `json:"caseID"`
	// FromID is the ID of the object to hold the link
	FromID string `json:"fromID"`
	// EventIDs of the events to be linked
	EventIDs []string `json:"eventIDs"`
	// PersonIDs of the persons to be linked
	PersonIDs []string `json:"personIDs"`
	// EntityIDs of the entitys to be linked
	EntityIDs []string `json:"entityIDs"`
	// FileIDs of the files to be linked
	FileIDs []string `json:"fileIDs"`
	// Bidirectional means that he link also should be created for the "ToID"
	Bidirectional bool `json:"bidirectional"`
}

// LinkCreateResponse is the output-object for linking objects
type LinkCreateResponse struct {
	Linked Link `json:"linked"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// LinkDeleteRequest is the input-object for removing a linked object
type LinkDeleteRequest struct {
	// ID of the object to delete the link for
	ID string `json:"id"`
	// CaseID of the case where the link belongs
	CaseID string `json:"caseID"`
}

// LinkDeleteResponse is the output-object for removing a link
type LinkDeleteResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// LinkGetRequest is the input-object for getting a links for an object
type LinkGetRequest struct {
	// ID of the object to get all links for
	ID string `json:"id"`
	// CaseID of the case where the link belongs
	CaseID string `json:"caseID"`
}

// LinkGetResponse is the output-object for getting a links for an object
type LinkGetResponse struct {
	Link Link `json:"link"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// LinkRemoveRequest is the input-object for removing linked objects with a
// specific object
type LinkRemoveRequest struct {
	// ID is the ID of the link to remove objects for
	ID string `json:"id"`
	// CaseID for the link
	CaseID string `json:"caseID"`
	// EventIDs of the events to be removed from the link
	EventIDs []string `json:"eventIDs"`
	// PersonIDs of the persons to be removed from the link
	PersonIDs []string `json:"personIDs"`
	// EntityIDs of the entities to be removed from the link
	EntityIDs []string `json:"entityIDs"`
	// FileIDs of the files to be removed from the link
	FileIDs []string `json:"fileIDs"`
}

// LinkRemoveResponse is the output-object for removing linked objects from a link
// objects
type LinkRemoveResponse struct {
	RemovedLinks Link `json:"removedLinks"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// PersonCreateRequest is the input-object for creating a person
type PersonCreateRequest struct {
	// CaseID of the case where the person should be created
	CaseID string `json:"caseID"`
	// FirstName(s) of the person
	FirstName string `json:"firstName"`
	// LastName(s) of the person
	LastName string `json:"lastName"`
	// EmailAddress of the person
	EmailAddress string `json:"emailAddress"`
	// PostalAddress of the person
	PostalAddress string `json:"postalAddress"`
	// WorkAddress of the person
	WorkAddress string `json:"workAddress"`
	// TelephoneNo of the person
	TelephoneNo string `json:"telephoneNo"`
	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// PersonCreateResponse is the output-object for creating a person
type PersonCreateResponse struct {
	Created Person `json:"created"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// PersonDeleteRequest is the input-object for deleting an existing person
type PersonDeleteRequest struct {
	// ID of the person to delete
	ID string `json:"id"`
	// CaseID of the case where the person should be deleted
	CaseID string `json:"caseID"`
}

// PersonDeleteResponse is the output-object for deleting an existing person
type PersonDeleteResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// PersonGetRequest is the input-object for getting an existing person
type PersonGetRequest struct {
	// ID of the person to get
	ID string `json:"id"`
	// CaseID of the case where the person should be gotten from
	CaseID string `json:"caseID"`
}

// PersonGetResponse is the output-object for getting an existing person
type PersonGetResponse struct {
	Person Person `json:"person"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// PersonListRequest is the input-object for listing all persons for a case
type PersonListRequest struct {
	// CaseID of the case to listen all persons
	CaseID string `json:"caseID"`
}

// PersonListResponse is the output-object for listing all persons for a case
type PersonListResponse struct {
	Persons []Person `json:"persons"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// PersonUpdateRequest is the input-object for updating an existing person
type PersonUpdateRequest struct {
	// ID of the person to update
	ID string `json:"id"`
	// CaseID of the case where the person should be updated
	CaseID string `json:"caseID"`
	// FirstName(s) of the person
	FirstName string `json:"firstName"`
	// LastName(s) of the person
	LastName string `json:"lastName"`
	// EmailAddress of the person
	EmailAddress string `json:"emailAddress"`
	// PostalAddress of the person
	PostalAddress string `json:"postalAddress"`
	// WorkAddress of the person
	WorkAddress string `json:"workAddress"`
	// TelephoneNo of the person
	TelephoneNo string `json:"telephoneNo"`
	// Custom is a free form with key-value pairs specified by the user.
	Custom map[string]interface{} `json:"custom"`
}

// PersonUpdateResponse is the output-object for updating an existing person
type PersonUpdateResponse struct {
	Updated Person `json:"updated"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// ProcessAbortRequest is the input-object for aborting a processing-job
type ProcessAbortRequest struct {
	// ID of the processing-job to abort
	ID string `json:"id"`
	// CaseID of the case the processing-job belongs to
	CaseID string `json:"caseID"`
}

// ProcessAbortResponse is the output-object for aborting a processing-job
type ProcessAbortResponse struct {
	Aborted Process `json:"aborted"`
}

// ProcessJobsRequest is the input-object for getting all processing-jobs for a
// case
type ProcessJobsRequest struct {
	// CaseID of the case to get the processing-jobs for
	CaseID string `json:"caseID"`
}

// ProcessJobsResponse is the output-object for getting all processing-jobs for a
// case
type ProcessJobsResponse struct {
	Processes []Process `json:"processes"`
}

// ProcessPauseRequest is the input-object for pausing a processing-job
type ProcessPauseRequest struct {
	// ID of the processing-job to pause
	ID string `json:"id"`
	// CaseID of the case the processing-job belongs to
	CaseID string `json:"caseID"`
}

// ProcessPauseResponse is the output-object for pausing a processing-job
type ProcessPauseResponse struct {
	Paused Process `json:"paused"`
}

// ProcessStartRequest is the input-object for starting a processing-job
type ProcessStartRequest struct {
	// CaseID of the case to start the processing for
	CaseID string `json:"caseID"`
	// FileIDs of the files to process
	FileIDs []string `json:"fileIDs"`
}

// ProcessStartResponse is the output-object for starting a processing-job
type ProcessStartResponse struct {
	Started Process `json:"started"`
}

// SearchTextRequest is the input-object for searching items
type SearchTextRequest struct {
	// ID for the case to search in
	CaseID string `json:"caseID"`
	// Text to search for
	Text string `json:"text"`
}

// SearchTextResponse is the output-object for searching items
type SearchTextResponse struct {
	Events    []Event     `json:"events"`
	Entities  []Entity    `json:"entities"`
	Persons   []Person    `json:"persons"`
	Files     []File      `json:"files"`
	Processed interface{} `json:"processed"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// SearchTimespanRequest is the input-object for searching items
type SearchTimespanRequest struct {
	// ID for the case to search in
	CaseID string `json:"caseID"`
	// FromDate is the unix-timestamp of where the timespan starts
	FromDate int64 `json:"fromDate"`
	// ToDate is the unix-timestamp of where the timespan finishes
	ToDate int64 `json:"toDate"`
}

// SearchTimespanResponse is the output-object for searching items
type SearchTimespanResponse struct {
	Events []Event `json:"events"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// TestCreateUserRequest is the input-object for creating a test-user
type TestCreateUserRequest struct {
	// Name of the user to create
	Name string `json:"name"`
	// ID of the user to create
	ID string `json:"id"`
	// Email of the user to create
	Email string `json:"email"`
	// Password for the new user
	Password string `json:"password"`
	// Secret for using the test-service
	Secret string `json:"secret,omitempty"`
}

// TestCreateUserResponse is the output-object for creating a test-user
type TestCreateUserResponse struct {
	// Token for the created user
	Token string `json:"token"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// TestDeleteUserRequest is the input-object for deleting a test-user
type TestDeleteUserRequest struct {
	// ID of the user to delete
	ID string `json:"id"`
	// Secret for using the test-service
	Secret string `json:"secret,omitempty"`
}

// TestDeleteUserResponse is the output-object for deleting a test-user
type TestDeleteUserResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// User holds information for a user in the timeline-investigator
type User struct {
	DisplayName string `json:"displayName"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phoneNumber"`
	PhotoURL    string `json:"photoURL"`
	ProviderID  string `json:"providerID"`
	UID         string `json:"uID"`
}
